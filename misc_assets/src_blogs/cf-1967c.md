---
displayMode: blog
title: CF-1967C
date: 2025-09-04
tags: [editorial]
---

This is a very easy problem but it did serve as a good exposition for intuition on a couple of ideas for me.

### Problem [CF-1967C](https://codeforces.com/problemset/problem/1967/C)

### Statement

> Let **lowbit**$(x)$ denote the value of the lowest binary bit of $x$, e.g.  
$\operatorname{lowbit}(12)=4$, $\operatorname{lowbit}(8)=8$.
> 
> For an array $a$ of length $n$, define an array $s$ of length $n$ by  
$$
s_k \equiv \left(\sum_{i = k - \operatorname{lowbit}(k) + 1}^{k} a_i \right) \bmod 998244353 \quad \text{for all } k,
$$  
> and call $s$ the **Fenwick Tree** of $a$. Letâ€™s denote it as $s = f(a)$.
> 
> For a positive integer $k$ and an array $a$, define $f^{k}(a)$ recursively as  
> $$
> f^{k}(a) =
> \begin{cases}
> f(a), & \text{if } k = 1, \\
> f(f^{k-1}(a)), & \text{otherwise.}
> \end{cases}
> $$
> 
> You are given an array $b$ of length $n$ and a positive integer $k$.  
> Find an array $a$ that satisfies $0 \le a_i < 998244353$ and $f^{k}(a) = b$.  
> 
> It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.


Constraints:

- $1 \leq n \leq 2 \cdot 10^5$
- $1 \leq k \leq 10^9$
- $0 \le b_i < 998244353$

### Solution

Firstly, it's time for me to admit that I never really bothered to learn how a fenwick tree internally works, due to almost always having preferred segment trees over them (only using the former as a blackbox when trying to squeeze one of my cursed $O(n \sqrt{n} \log{n})$ implementations into the TL). Knowing this, the reader shall excuse me for spending some time understanding what's going on with $\operatorname{lowbit}(x)$.

Let's define $\operatorname{lsb}(x) = \log_2 (\operatorname{lowbit}(x))$ for convenience.

So, what does the sequence $\operatorname{lowbit}(x)$ even look like? It takes the following form:

> 1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16 ...

Clearly, $\operatorname{lowbit}(x)$ is simply the greatest power of 2 that divides $x$, and any value of $\operatorname{lowbit}(x)$, say $d$, repeats with a period of $d$ save for places where it gets "overridden" by greater values of $d$.

Now, what form do the segments mentioned in the problem $[i - \operatorname{lowbit}(i) + 1]$ take?

<image1 here>

It isn't difficult to see that this structure is essentially just half a segment tree (to be more specific, it is what we would be left with upon deleting the segment corresponding to the right child of every node).

Here's an illustration that should make this clearer. The blue nodes (and their corresponding ranges) are the ones present in our structure, while the red ones aren't.

<image2 here>

Let's give this thing a name, we'll call it a ghost segment tree (after the red ghost nodes/segments).

What are some useful properties of this structure?

1. For all $i$, $\operatorname{lowbit}(j) = \operatorname{lowbit}(i -  \operatorname{lowbit}(i) + j)$ for $1 \leq j \leq \operatorname{lowbit}(i)$. This simplifies analysis by a great deal, as we now need to only concern ourselves with prefixes of the $\operatorname{lowbit}(i)$ that have lengths which are some powers of two.
2. Let's define $C(i)$ as the set of all $j$ where $j - \operatorname{lowbit}(j) + 1 \leq i \leq j$. Then $\operatorname{lowbit}(j_1) \neq \operatorname{lowbit}(j_2) \quad \forall \quad j_1, j_2 \in C(i) : j_1 \neq j_2$.

How do these properties help us? Consider the first property, it implies that no matter what $i$ we choose, the minimal "subtree" of this "ghost segment tree" that contains the segment $[i - \operatorname{lowbit}(i) + 1, i]$ will conveniently be isomorphic to the minimal subtree over the segment $[1, \operatorname{lowbit}(i)]$. This is extremely convenient because we now know that for any $i$, the minimal subtree containing its segment is going to be a perfect binary tree of height $\operatorname{lsb}(i)$ (well, as perfect as it can get with half of its node being ghost nodes, but you get the point), and we can use properties implied from this symmetry to design efficient algorithms.

For instance, let's consider finding the sum over $[i - \operatorname{lowbit}(i) + 1, i]$ for all $i$. Assume $\operatorname{lowbit}(i) = 8$, and look at the diagram above again.




<TO BE CONTINUED>