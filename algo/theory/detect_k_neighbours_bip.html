<!DOCTYPE html><html lang="en" class="h-full"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Welcome to the Sunny Side!</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDGES615HV"></script><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-FDGES615HV");</script><script type="module">
    import { currentSkin } from '/src/stores/skin.ts';
    currentSkin.subscribe((skin) => {
      const rootCls = `h-full bg-bg text-text ${skin.classes.body}`;
      document.documentElement.className = rootCls;
      document.body.className = rootCls;
      // set CSS variables on :root
      const rs = document.documentElement.style;
      Object.entries(skin.cssVars).forEach(([k,v]) => rs.setProperty(`--${k}`, v));
      if (skin.inlineStyles?.body) {
        Object.assign(document.body.style, skin.inlineStyles.body);
      }
    });
  </script><link rel="stylesheet" href="/_astro/_slug_.B_lpCp7p.css"></head> <body class="h-full"> <div class="h-screen w-screen grid grid-cols-1 md:grid-cols-[1fr_auto] grid-rows-[auto_1fr] md:grid-rows-1"> <!-- Content --> <main class="overflow-y-auto overflow-x-hidden order-2 md:order-none bg-surface text-text transition-colors duration-150 ease-retro"> <div id="ssr-fallback" class="p-4 prose prose-invert max-w-none"><h2>Outline</h2>
<ul class="outline-list">
<li>Problem</li>
<li>Solution
  <ul>
    <li>Requirements</li>
    <li>Algorithm</li>
    <li>Complexity Analysis</li>
  </ul>
</li>
<li>Example Problems
  <ul>
    <li>CF-1957F2</li>
  </ul>
</li>
</ul>
<p>I thought of this idea while solving <a href="https://codeforces.com/problemset/problem/1957/F2">1957F2</a>. It is extremely easy, cute (at least compared to the official solution), and can be generalized, so I'll share it here.</p>
<h2>Problem</h2>
<blockquote>
<p>Given two sets of vertices $X$ and $Y$ and a boolean function $f: X \times Y \rightarrow \{0, 1\}$, we define a bipartite graph $G = (V = (X \cup Y), E = ((u, v) \mid u \in X, v \in Y, f(u, v) = 1))$</p>
<p>We need to find $k$ adjacent vertices in $G$ for every node $u \in X$.</p>
</blockquote>
<h2>Solution</h2>
<h3>Requirements</h3>
<ol>
<li>We can compute $f(u, v)$ in $O(x)$ time.</li>
<li>We can construct a data structure $D(Z)$ from some subset $Z \subseteq Y$ in $O(p(\vert Z \vert))$ time, such that we can query if there exists some $v \in Z$ such that $f(u, v) = 1$ in $O(q(\vert Z \vert))$ time.</li>
</ol>
<h3>Algorithm</h3>
<details><summary class ="spoiler-summary">Definitions</summary>
<div class = "spoiler-content">
<ul>
<li> $n = \vert X \vert$ </li>
<li> $m = \vert Y \vert$ </li>
<li> Let $Q(u, D(Z))$ be the query function which checks if there exists 
some $v \in Z$ such that $f(u, v) = 1$.</li>
</ul>
</div>
</details>
<p>We will use block decomposition with $B$ as the block size. The algorithm works in the following way:</p>
<ol>
<li>Divide $Y$ into $\lceil m/B \rceil$ disjoint subsets of size $B$. Let the $i$'th subset be $S_i$</li>
<li>Iterate over the subsets, while maintaining a list $L$ of all $u \in X$ for which we have found $< k$ neighbors till that point of time ($L = X$ initially).</li>
<li>At subset $S_i$, we will do the following:
<ol>
<li>Construct $D(S_i)$.</li>
<li>Create an empty list $H_i$, and add $u$ to $H_i$ (also delete it from $L$) for all $u \in L$ such that $Q(u, D(S_i)) = 1$.</li>
<li>Compute $f(u, v) \; \forall \; u \in H_i, v\in S_i$, and mark $v$ as a neighbor of  $u$ if $f(u, v) = 1$.</li>
<li>For every $u \in H_i$ for which we haven't found $k$ neighbors yet, add $u$ back to $L$.</li>
</ol>
</li>
</ol>
<details><summary class ="spoiler-summary">Note</summary>
<div class = "spoiler-content">
We can trivially solve this problem faster for $k = 1$ by 
constructing a segment tree over $Y$, doing dfs on it, and passing down elements 
of $X$ to one of the two children based on queries from $D$ constructed on 
elements from one of the two children.
</div>
</details>
<h3>Complexity Analysis</h3>
<p>The cumulative time for building all the data structures will be $O(\lceil m/B \rceil \cdot p(B))$.</p>
<p>For queries:</p>
<ol>
<li>At every $S_i$, we query $Q(u, D(S_i)) \; \forall \; u \in L$. Since $\vert L \vert \leq n$, this takes $O(n \cdot \lceil m/B\rceil \cdot q(B))$ time.</li>
<li>It's easy to see that every node $u \in X$ is added to  $H_i$ for at most $k$ distinct values of $i$. Every time a $u$ is added to $H_i$, we compute $f(u, v)$ for $\leq B$ distinct values of $v$. This takes $O(n \cdot B \cdot k \cdot x)$ time.</li>
</ol>
<p>Therefore the total time taken is:</p>
<p>$$
O(n \cdot B \cdot k \cdot x + \lceil m/B \rceil \cdot (p(B) + n\cdot q(B)))
$$</p>
<p>The choice of $B$ is highly problem dependent, but in most setups where this idea could be used, I think we would have $k \lll n$ and $q$ would be pretty fast. I recommend solving the example problem to understand why the complexity is decent if you think it is garbage.</p>
<h2>Example Problems</h2>
<h3>1. <a href="https://codeforces.com/problemset/problem/1957/F2">CF-1957F2</a></h3>
<blockquote>
<p>You are given an undirected tree of $n$ nodes. Each node $v$ has a value $a_v$ written on it. You have to answer queries related to the tree.</p>
<p>You are given $q$ queries. In each query, you are given 5 integers, $u_1$, $v_1$, $u_2$, $v_2$, and $k$. Denote the count of nodes with value $c$ on the path $u_1 \to v_1$ with $x_c$, and the count of nodes with value $c$ on the path $u_2 \to v_2$ with $y_c$. If there are $z$ such values of $c$ such that $x_c \neq y_c$, output any $\min(z, k)$ such values in any order.</p>
</blockquote>
<details><summary class ="spoiler-summary">Solution</summary>
<div class = "spoiler-content">
To be updated
</div>
</details>
</div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="iHJI7" component-url="/_astro/ContentPane.CWksgNm-.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{&quot;ssrPath&quot;:[0,&quot;/algo/theory/detect_k_neighbours_bip.html&quot;],&quot;ssrHtml&quot;:[0,&quot;&lt;h2&gt;Outline&lt;/h2&gt;\n&lt;ul class=\&quot;outline-list\&quot;&gt;\n&lt;li&gt;Problem&lt;/li&gt;\n&lt;li&gt;Solution\n  &lt;ul&gt;\n    &lt;li&gt;Requirements&lt;/li&gt;\n    &lt;li&gt;Algorithm&lt;/li&gt;\n    &lt;li&gt;Complexity Analysis&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Example Problems\n  &lt;ul&gt;\n    &lt;li&gt;CF-1957F2&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;I thought of this idea while solving &lt;a href=\&quot;https://codeforces.com/problemset/problem/1957/F2\&quot;&gt;1957F2&lt;/a&gt;. It is extremely easy, cute (at least compared to the official solution), and can be generalized, so I&#39;ll share it here.&lt;/p&gt;\n&lt;h2&gt;Problem&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Given two sets of vertices $X$ and $Y$ and a boolean function $f: X \\times Y \\rightarrow \\{0, 1\\}$, we define a bipartite graph $G = (V = (X \\cup Y), E = ((u, v) \\mid u \\in X, v \\in Y, f(u, v) = 1))$&lt;/p&gt;\n&lt;p&gt;We need to find $k$ adjacent vertices in $G$ for every node $u \\in X$.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;Solution&lt;/h2&gt;\n&lt;h3&gt;Requirements&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;We can compute $f(u, v)$ in $O(x)$ time.&lt;/li&gt;\n&lt;li&gt;We can construct a data structure $D(Z)$ from some subset $Z \\subseteq Y$ in $O(p(\\vert Z \\vert))$ time, such that we can query if there exists some $v \\in Z$ such that $f(u, v) = 1$ in $O(q(\\vert Z \\vert))$ time.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3&gt;Algorithm&lt;/h3&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Definitions&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\n&lt;ul&gt;\n&lt;li&gt; $n = \\vert X \\vert$ &lt;/li&gt;\n&lt;li&gt; $m = \\vert Y \\vert$ &lt;/li&gt;\n&lt;li&gt; Let $Q(u, D(Z))$ be the query function which checks if there exists \nsome $v \\in Z$ such that $f(u, v) = 1$.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;\n&lt;/details&gt;\n&lt;p&gt;We will use block decomposition with $B$ as the block size. The algorithm works in the following way:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Divide $Y$ into $\\lceil m/B \\rceil$ disjoint subsets of size $B$. Let the $i$&#39;th subset be $S_i$&lt;/li&gt;\n&lt;li&gt;Iterate over the subsets, while maintaining a list $L$ of all $u \\in X$ for which we have found $&lt; k$ neighbors till that point of time ($L = X$ initially).&lt;/li&gt;\n&lt;li&gt;At subset $S_i$, we will do the following:\n&lt;ol&gt;\n&lt;li&gt;Construct $D(S_i)$.&lt;/li&gt;\n&lt;li&gt;Create an empty list $H_i$, and add $u$ to $H_i$ (also delete it from $L$) for all $u \\in L$ such that $Q(u, D(S_i)) = 1$.&lt;/li&gt;\n&lt;li&gt;Compute $f(u, v) \\; \\forall \\; u \\in H_i, v\\in S_i$, and mark $v$ as a neighbor of  $u$ if $f(u, v) = 1$.&lt;/li&gt;\n&lt;li&gt;For every $u \\in H_i$ for which we haven&#39;t found $k$ neighbors yet, add $u$ back to $L$.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Note&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\nWe can trivially solve this problem faster for $k = 1$ by \nconstructing a segment tree over $Y$, doing dfs on it, and passing down elements \nof $X$ to one of the two children based on queries from $D$ constructed on \nelements from one of the two children.\n&lt;/div&gt;\n&lt;/details&gt;\n&lt;h3&gt;Complexity Analysis&lt;/h3&gt;\n&lt;p&gt;The cumulative time for building all the data structures will be $O(\\lceil m/B \\rceil \\cdot p(B))$.&lt;/p&gt;\n&lt;p&gt;For queries:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;At every $S_i$, we query $Q(u, D(S_i)) \\; \\forall \\; u \\in L$. Since $\\vert L \\vert \\leq n$, this takes $O(n \\cdot \\lceil m/B\\rceil \\cdot q(B))$ time.&lt;/li&gt;\n&lt;li&gt;It&#39;s easy to see that every node $u \\in X$ is added to  $H_i$ for at most $k$ distinct values of $i$. Every time a $u$ is added to $H_i$, we compute $f(u, v)$ for $\\leq B$ distinct values of $v$. This takes $O(n \\cdot B \\cdot k \\cdot x)$ time.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Therefore the total time taken is:&lt;/p&gt;\n&lt;p&gt;$$\nO(n \\cdot B \\cdot k \\cdot x + \\lceil m/B \\rceil \\cdot (p(B) + n\\cdot q(B)))\n$$&lt;/p&gt;\n&lt;p&gt;The choice of $B$ is highly problem dependent, but in most setups where this idea could be used, I think we would have $k \\lll n$ and $q$ would be pretty fast. I recommend solving the example problem to understand why the complexity is decent if you think it is garbage.&lt;/p&gt;\n&lt;h2&gt;Example Problems&lt;/h2&gt;\n&lt;h3&gt;1. &lt;a href=\&quot;https://codeforces.com/problemset/problem/1957/F2\&quot;&gt;CF-1957F2&lt;/a&gt;&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;You are given an undirected tree of $n$ nodes. Each node $v$ has a value $a_v$ written on it. You have to answer queries related to the tree.&lt;/p&gt;\n&lt;p&gt;You are given $q$ queries. In each query, you are given 5 integers, $u_1$, $v_1$, $u_2$, $v_2$, and $k$. Denote the count of nodes with value $c$ on the path $u_1 \\to v_1$ with $x_c$, and the count of nodes with value $c$ on the path $u_2 \\to v_2$ with $y_c$. If there are $z$ such values of $c$ such that $x_c \\neq y_c$, output any $\\min(z, k)$ such values in any order.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Solution&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\nTo be updated\n&lt;/div&gt;\n&lt;/details&gt;\n&quot;],&quot;ssrFrontmatter&quot;:[0,{&quot;displayMode&quot;:[0,&quot;blog&quot;],&quot;title&quot;:[0,&quot;Finding K neighbours in an implicitly defined bipartite graph&quot;],&quot;date&quot;:[0,&quot;2024-08-15&quot;],&quot;tags&quot;:[1,[[0,&quot;algorithm&quot;]]]}],&quot;ssrFlags&quot;:[0,{&quot;isBlog&quot;:[0,true],&quot;isMusings&quot;:[0,false]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;ContentPane&quot;,&quot;value&quot;:true}" await-children><!--[--><!--[!--><!--[1--><div class="h-full w-full bg-cover bg-center bg-no-repeat" style="background-image: url('/_astro/expoutput-1500w.BYFb0Fuh.webp');"></div><!--]--><!--]--><!--]--><!--astro:end--></astro-island> </main> <!-- Terminal --> <aside class="border-t border-zinc-700 md:border-t-0 md:border-l md:border-zinc-700 order-1 md:order-none"> <astro-island uid="1NBGTk" component-url="/_astro/TerminalPane.DRvAhnyr.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;TerminalPane&quot;,&quot;value&quot;:true}" await-children><!--[--><div class="h-full flex flex-col bg-zinc-900 desktop-wrapper svelte-twihms"><div class="md:hidden flex items-center justify-between px-3 py-2 border-b border-zinc-700"><span class="font-mono text-xs text-zinc-400">terminal</span> <button class="text-zinc-300" aria-label="Toggle terminal"><!--[!-->▲<!--]--></button></div> <!--[1--><button class="desktop-toggle hidden md:flex svelte-twihms" aria-label="Collapse terminal">▶</button><!--]--> <div class="flex-1 overflow-hidden"><div class="terminal-content body svelte-twihms"><div class="terminal-shell h-full w-full svelte-1asehid focused"></div><!----></div></div></div><!--]--><!--astro:end--></astro-island> </aside> </div> </body></html>