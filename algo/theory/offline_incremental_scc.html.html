<!DOCTYPE html><html lang="en" class="h-full"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Welcome to the Sunny Side!</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDGES615HV"></script><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-FDGES615HV");</script><script type="module">
    import { currentSkin } from '/src/stores/skin.ts';
    currentSkin.subscribe((skin) => {
      const rootCls = `h-full bg-bg text-text ${skin.classes.body}`;
      document.documentElement.className = rootCls;
      document.body.className = rootCls;
      // set CSS variables on :root
      const rs = document.documentElement.style;
      Object.entries(skin.cssVars).forEach(([k,v]) => rs.setProperty(`--${k}`, v));
      if (skin.inlineStyles?.body) {
        Object.assign(document.body.style, skin.inlineStyles.body);
      }
    });
  </script><link rel="stylesheet" href="/_astro/_slug_.B_lpCp7p.css"></head> <body class="h-full"> <div class="h-screen w-screen grid grid-cols-1 md:grid-cols-[1fr_auto] grid-rows-[auto_1fr] md:grid-rows-1"> <!-- Content --> <main class="overflow-y-auto overflow-x-hidden order-2 md:order-none bg-surface text-text transition-colors duration-150 ease-retro"> <div id="ssr-fallback" class="p-4 prose prose-invert max-w-none"><h2>Outline</h2>
<ul class="outline-list">
<li>Problem</li>
<li>Observations</li>
<li>Algorithm
  <ul>
    <li>Pre-Processing</li>
    <li>Answering Queries
      <ul>
        <li>Queries based on number of edges added</li>
        <li>Queries based on nodes</li>
      </ul>
    </li>
  </ul>
</li>
<li>Complexity Analysis</li>
<li>Example Problems
  <ul>
    <li>Problem L, GP of Zheijang</li>
    <li>CF1989F</li>
    <li>ONTAK 2009 Godzilla</li>
  </ul>
</li>
</ul>
<p>Hello, in this blog I'll explain the algorithm from <a href="https://codeforces.com/blog/entry/91608">this Radewoosh blog</a>. The linked blog is understandable and well-written (and honestly, this idea can be in summarized in one line as &quot;dnc over timeline&quot;) but it's a bit informal and I feel like writing something, hence this blog.</p>
<h2>Problem</h2>
<p>We are going to learn to maintain information about SCCs in a directed graph when have a problem with the following general structure:</p>
<blockquote>
<p>Given an initially empty digraph $G$, and a list of $m$ directed edges $E$ that are sequentially added to the graph, we need to answer queries of the following form: Find some information about SCCs in $G$ after the first $i$ edges are added</p>
</blockquote>
<p>Some specific examples of queries would be:</p>
<ol>
<li>Find the smallest $i$ such that $u$ and $v$ belong to the same SCC after the first $i$ edges are added.</li>
<li>Find the size of the SCC containing node $u$ after $i$ edges are added.</li>
</ol>
<p>Note: As the title suggests, <em>the idea described here is only applicable when we are allowed to process the queries offline</em>.</p>
<h2>Observations</h2>
<p>Notation:
Define $S(u, i)$ to be the set of nodes in the SCC of node $u$ after the addition of the first $i$ edges to $G$</p>
<p>The entire algorithm is based around a trivial observation:</p>
<blockquote>
<p>For every pair of nodes $(u, v)$ we have, $(S(u, j) \neq S(v, j)) \implies (S(u, k) \neq S(v, k)) \forall k \leq j$.</p>
</blockquote>
<p>Therefore, for every edge $E_i = (u \rightarrow v)$, we define $t_i = \arg \min_j \left( S(u, j) = S(v, j) \right)$ (and trivially infinite if they are never equal). One can observe that the presence of $E_i$ in $G$ doesn't affect the structure of any SCC until the the first $t_i$ edges are added.</p>
<div style="text-align:center"><img src="/assets/offline-incremental-scc/slideshow.gif" /></div>
<h2>Algorithm</h2>
<h3>Pre-Processing</h3>
<p>We will be doing DnC over the timeline of addition of edges (ie, $[1, m]$) with a recursive function of the form $f(l, r, \text{edge list})$. For every call $f(l, r, \text{edge list})$, our $\text{edge list}$ will contain all edges $E_i$ for which $l \leq t_i \leq r$.</p>
<p>Let us look at what we do in the first call, $f(1, m, \text{edge list})$ to understand what the generalized recursive call will be doing:</p>
<ol>
<li>Define $\text{mid} = (1 + m)/2$. We add all edges $E_i : i \leq \text{mid}$ to our initially empty graph and find SCCs induced by these edges. This can be done in $O(x)$ time where $x$ is the number of edges.</li>
<li>Store information about SCCs/answer queries.</li>
<li>For every edge $E_i = (u \rightarrow v) : i \leq \text{mid}$, if $\text{SCC}_u = \text{SCC}_v$, then we can deduce that $t_i \leq (1 + n)/2$. Otherwise, $t_i > \text{mid}$. Separate these edges into two groups $\text{G}_1$ and $\text{G}_2$ respectively. Add all edges $E_i : i > \text{mid}$ to $\text{G}_2$.</li>
<li>Call $f(1, \text{mid} - 1, \text{G}_1)$.</li>
<li>Once we return from this call, compress all the SCCs induced by the addition of edges in $\text{G}_1$.</li>
<li>Call $f(\text{mid} + 1, m, \text{G}_2)$. **Remember, this call must operate on the compressed graph.</li>
</ol>
<p>Notice that when we execute $f(l, r, \text{edge list})$, it is essential that we perform the computation within it (finding SCCs induced by $\text{edge list}$, checking if endpoints of edges belong to the same SCC, etc.) upon the compressed graph induced by all edges $E_i : t_i < l$. This can be done easily by maintaining a global graph $G$, and performing compressions introduced by $\text{edge list}$ of $f(l, r, \text{edge list})$ when we return from this function (therefore, step $5$ will actually be performed by $f(1, \text{mid} - 1, \text{G}_1)$ and the calls in its subtree before they return).</p>
<p>The pseudo code for our algorithm takes the following form:</p>
<pre class="hljs"><code>create an empty graph G with n nodes

def f(l, r, edge list):

    mid = (l + r)/2

    initialize SCC structure from G
    for every edge E[i] = (u -&gt; v) in edge list:
        if(i &lt;= mid)
            add (u -&gt; v) to SCC structure

    compute SCCs
    
    problem specific stuff (storing info/answering queries)

    initialize empty edge lists G1 and G2
    for every edge E[i] = (u -&gt; v) in edge list:
        if(i &lt;= mid):
            if(SCC[u] = SCC[v])
                add E[i] to G1
            else
                add E[i] to G2
        else
            add E[i] to G2

    f(l, mid - 1, G1)
    f(mid + 1, r, G2)
    
    for every SCC induced by G1:
        compress SCC into a single node in G
enddef

f(1, m, edge list)
</code></pre>
<h3>Answering Queries</h3>
<p>This is quite problem-dependent. I have only seen a couple of problems which use this idea so I will just describe two ways of answering queries that I know of:</p>
<h4><u>Queries based on number of edges added</u></h4>
<p>These queries are of the form:</p>
<blockquote>
<p>Find some information about the SCCs of a graph after $i$ edges are added.</p>
</blockquote>
<p>Such queries can be answered by maintaining SCCs using DSU/Small-to-Large merging/(some other ds) as we go through the recursion in a way such that after performing the computation for $f(l, r, \text{edge list})$, all information about SCCs after adding the first $(l + r)/2$ edges will be queryable from our DS. We then answer all queries with $i = (l + r)/2$.</p>
<p><strong>Note</strong>: This is possible because if the SCC compression for $f(l_1, r_1, \text{edge list}_1)$ is done before the SCC compression for $f(l_2, r_2, \text{edge list}_2)$, then we have either  $(l_1 \leq l_2 \text{ and } r_1 \leq r_2)$ or $(l_2 \leq l_1 \text{ and } r_1 \leq r_2)$. Therefore, SCCs only expand(unite) as we recurse through the calls.</p>
<h4><u>Queries based on nodes</u></h4>
<p>This is a somewhat non-trivial technique, which can be used to answer queries like:</p>
<blockquote>
<p>Find the smallest $i$ such that nodes $u$ and $v$ belong to the same SCC after the first $i$ edges are added to $G$</p>
</blockquote>
<p>We solve it in the following way:</p>
<ol>
<li>We maintain an initially empty undirected weighted graph $U$.</li>
<li>At every call $f(l, r, \text{edge list})$, for every edge $E_i = (u \rightarrow v) \in \text{G}1$, we add an edge $(u, v)$ with weight $(l + r)/2$ to $U$.</li>
<li>Finally, $U$ contains $O(m\log_2{m})$ edges, with weights $\leq m$.</li>
<li>To answer a query for a pair of nodes $(u, v)$, one can observe that the problem is equivalent to finding the minimized maximum weight edge on any path between $u$ and $v$ in  $U$. This can be done by constructing the MST of $U$ and answering path maximum queries.</li>
</ol>
<p><strong>Note</strong>: Since all edges in $U$ have weight $\leq m$, we can avoid sorting its edge list and simply iterate over edge weights (in kruskals) to find the MST and get rid of a log factor, allowing construction of the MST in $O(m\log_2{m})$.</p>
<h2>Complexity Analysis</h2>
<p>Since we split apart $\text{edge list}$ into two disjoint groups $\text{G}1$ and $\text{G}2$ in every call $f(l, r, \text{edge list})$, this ensures that every edge occurs exactly once on every level of the recursion. For every call $f(l, r, \text{edge list})$, we perform a $O(\vert \text{edge list} \vert)$ computation. So on every level, we perform a $O(\sum_{f(l, r, \text{edge list})}(\vert \text{edge list} \vert)) = O(m)$ computation. There are $\log_2(m)$ levels of the recursion, so our pre-processing algorithm works in $O(m \log_2{m})$.</p>
<p>The time taken for answering queries is problem dependent.</p>
<h2>Example Problems</h2>
<h3>1. <a href="https://qoj.ac/contest/796/problem/2214?v=1">Problem L, Grand Prix of Zheijang (Open Cup 2018-19)</a></h3>
<details><summary class ="spoiler-summary">Solution</summary>
<div class = "spoiler-content">
Trivial, just use DSU to maintain size of each SCC.
</div>
</details>
<h3>2. <a href="https://codeforces.com/problemset/problem/1989/F">CF-1989F</a></h3>
<details><summary class ="spoiler-summary">Solution</summary>
<div class = "spoiler-content">
To be updated
</div>
</details>
<h3>3. <a href="https://www.acmicpc.net/problem/8496">ONTAK 2009 Godzilla</a></h3>
<details><summary class ="spoiler-summary">Solution</summary>
<div class = "spoiler-content">
To be updated
</div>
</details>
</div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z19Utdl" component-url="/_astro/ContentPane.CWksgNm-.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{&quot;ssrPath&quot;:[0,&quot;/algo/theory/offline_incremental_scc.html&quot;],&quot;ssrHtml&quot;:[0,&quot;&lt;h2&gt;Outline&lt;/h2&gt;\n&lt;ul class=\&quot;outline-list\&quot;&gt;\n&lt;li&gt;Problem&lt;/li&gt;\n&lt;li&gt;Observations&lt;/li&gt;\n&lt;li&gt;Algorithm\n  &lt;ul&gt;\n    &lt;li&gt;Pre-Processing&lt;/li&gt;\n    &lt;li&gt;Answering Queries\n      &lt;ul&gt;\n        &lt;li&gt;Queries based on number of edges added&lt;/li&gt;\n        &lt;li&gt;Queries based on nodes&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Complexity Analysis&lt;/li&gt;\n&lt;li&gt;Example Problems\n  &lt;ul&gt;\n    &lt;li&gt;Problem L, GP of Zheijang&lt;/li&gt;\n    &lt;li&gt;CF1989F&lt;/li&gt;\n    &lt;li&gt;ONTAK 2009 Godzilla&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Hello, in this blog I&#39;ll explain the algorithm from &lt;a href=\&quot;https://codeforces.com/blog/entry/91608\&quot;&gt;this Radewoosh blog&lt;/a&gt;. The linked blog is understandable and well-written (and honestly, this idea can be in summarized in one line as &amp;quot;dnc over timeline&amp;quot;) but it&#39;s a bit informal and I feel like writing something, hence this blog.&lt;/p&gt;\n&lt;h2&gt;Problem&lt;/h2&gt;\n&lt;p&gt;We are going to learn to maintain information about SCCs in a directed graph when have a problem with the following general structure:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Given an initially empty digraph $G$, and a list of $m$ directed edges $E$ that are sequentially added to the graph, we need to answer queries of the following form: Find some information about SCCs in $G$ after the first $i$ edges are added&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Some specific examples of queries would be:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Find the smallest $i$ such that $u$ and $v$ belong to the same SCC after the first $i$ edges are added.&lt;/li&gt;\n&lt;li&gt;Find the size of the SCC containing node $u$ after $i$ edges are added.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Note: As the title suggests, &lt;em&gt;the idea described here is only applicable when we are allowed to process the queries offline&lt;/em&gt;.&lt;/p&gt;\n&lt;h2&gt;Observations&lt;/h2&gt;\n&lt;p&gt;Notation:\nDefine $S(u, i)$ to be the set of nodes in the SCC of node $u$ after the addition of the first $i$ edges to $G$&lt;/p&gt;\n&lt;p&gt;The entire algorithm is based around a trivial observation:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;For every pair of nodes $(u, v)$ we have, $(S(u, j) \\neq S(v, j)) \\implies (S(u, k) \\neq S(v, k)) \\forall k \\leq j$.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Therefore, for every edge $E_i = (u \\rightarrow v)$, we define $t_i = \\arg \\min_j \\left( S(u, j) = S(v, j) \\right)$ (and trivially infinite if they are never equal). One can observe that the presence of $E_i$ in $G$ doesn&#39;t affect the structure of any SCC until the the first $t_i$ edges are added.&lt;/p&gt;\n&lt;div style=\&quot;text-align:center\&quot;&gt;&lt;img src=\&quot;/assets/offline-incremental-scc/slideshow.gif\&quot; /&gt;&lt;/div&gt;\n&lt;h2&gt;Algorithm&lt;/h2&gt;\n&lt;h3&gt;Pre-Processing&lt;/h3&gt;\n&lt;p&gt;We will be doing DnC over the timeline of addition of edges (ie, $[1, m]$) with a recursive function of the form $f(l, r, \\text{edge list})$. For every call $f(l, r, \\text{edge list})$, our $\\text{edge list}$ will contain all edges $E_i$ for which $l \\leq t_i \\leq r$.&lt;/p&gt;\n&lt;p&gt;Let us look at what we do in the first call, $f(1, m, \\text{edge list})$ to understand what the generalized recursive call will be doing:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Define $\\text{mid} = (1 + m)/2$. We add all edges $E_i : i \\leq \\text{mid}$ to our initially empty graph and find SCCs induced by these edges. This can be done in $O(x)$ time where $x$ is the number of edges.&lt;/li&gt;\n&lt;li&gt;Store information about SCCs/answer queries.&lt;/li&gt;\n&lt;li&gt;For every edge $E_i = (u \\rightarrow v) : i \\leq \\text{mid}$, if $\\text{SCC}_u = \\text{SCC}_v$, then we can deduce that $t_i \\leq (1 + n)/2$. Otherwise, $t_i &gt; \\text{mid}$. Separate these edges into two groups $\\text{G}_1$ and $\\text{G}_2$ respectively. Add all edges $E_i : i &gt; \\text{mid}$ to $\\text{G}_2$.&lt;/li&gt;\n&lt;li&gt;Call $f(1, \\text{mid} - 1, \\text{G}_1)$.&lt;/li&gt;\n&lt;li&gt;Once we return from this call, compress all the SCCs induced by the addition of edges in $\\text{G}_1$.&lt;/li&gt;\n&lt;li&gt;Call $f(\\text{mid} + 1, m, \\text{G}_2)$. **Remember, this call must operate on the compressed graph.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Notice that when we execute $f(l, r, \\text{edge list})$, it is essential that we perform the computation within it (finding SCCs induced by $\\text{edge list}$, checking if endpoints of edges belong to the same SCC, etc.) upon the compressed graph induced by all edges $E_i : t_i &lt; l$. This can be done easily by maintaining a global graph $G$, and performing compressions introduced by $\\text{edge list}$ of $f(l, r, \\text{edge list})$ when we return from this function (therefore, step $5$ will actually be performed by $f(1, \\text{mid} - 1, \\text{G}_1)$ and the calls in its subtree before they return).&lt;/p&gt;\n&lt;p&gt;The pseudo code for our algorithm takes the following form:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;create an empty graph G with n nodes\n\ndef f(l, r, edge list):\n\n    mid = (l + r)/2\n\n    initialize SCC structure from G\n    for every edge E[i] = (u -&amp;gt; v) in edge list:\n        if(i &amp;lt;= mid)\n            add (u -&amp;gt; v) to SCC structure\n\n    compute SCCs\n    \n    problem specific stuff (storing info/answering queries)\n\n    initialize empty edge lists G1 and G2\n    for every edge E[i] = (u -&amp;gt; v) in edge list:\n        if(i &amp;lt;= mid):\n            if(SCC[u] = SCC[v])\n                add E[i] to G1\n            else\n                add E[i] to G2\n        else\n            add E[i] to G2\n\n    f(l, mid - 1, G1)\n    f(mid + 1, r, G2)\n    \n    for every SCC induced by G1:\n        compress SCC into a single node in G\nenddef\n\nf(1, m, edge list)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Answering Queries&lt;/h3&gt;\n&lt;p&gt;This is quite problem-dependent. I have only seen a couple of problems which use this idea so I will just describe two ways of answering queries that I know of:&lt;/p&gt;\n&lt;h4&gt;&lt;u&gt;Queries based on number of edges added&lt;/u&gt;&lt;/h4&gt;\n&lt;p&gt;These queries are of the form:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Find some information about the SCCs of a graph after $i$ edges are added.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Such queries can be answered by maintaining SCCs using DSU/Small-to-Large merging/(some other ds) as we go through the recursion in a way such that after performing the computation for $f(l, r, \\text{edge list})$, all information about SCCs after adding the first $(l + r)/2$ edges will be queryable from our DS. We then answer all queries with $i = (l + r)/2$.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This is possible because if the SCC compression for $f(l_1, r_1, \\text{edge list}_1)$ is done before the SCC compression for $f(l_2, r_2, \\text{edge list}_2)$, then we have either  $(l_1 \\leq l_2 \\text{ and } r_1 \\leq r_2)$ or $(l_2 \\leq l_1 \\text{ and } r_1 \\leq r_2)$. Therefore, SCCs only expand(unite) as we recurse through the calls.&lt;/p&gt;\n&lt;h4&gt;&lt;u&gt;Queries based on nodes&lt;/u&gt;&lt;/h4&gt;\n&lt;p&gt;This is a somewhat non-trivial technique, which can be used to answer queries like:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Find the smallest $i$ such that nodes $u$ and $v$ belong to the same SCC after the first $i$ edges are added to $G$&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;We solve it in the following way:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;We maintain an initially empty undirected weighted graph $U$.&lt;/li&gt;\n&lt;li&gt;At every call $f(l, r, \\text{edge list})$, for every edge $E_i = (u \\rightarrow v) \\in \\text{G}1$, we add an edge $(u, v)$ with weight $(l + r)/2$ to $U$.&lt;/li&gt;\n&lt;li&gt;Finally, $U$ contains $O(m\\log_2{m})$ edges, with weights $\\leq m$.&lt;/li&gt;\n&lt;li&gt;To answer a query for a pair of nodes $(u, v)$, one can observe that the problem is equivalent to finding the minimized maximum weight edge on any path between $u$ and $v$ in  $U$. This can be done by constructing the MST of $U$ and answering path maximum queries.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Since all edges in $U$ have weight $\\leq m$, we can avoid sorting its edge list and simply iterate over edge weights (in kruskals) to find the MST and get rid of a log factor, allowing construction of the MST in $O(m\\log_2{m})$.&lt;/p&gt;\n&lt;h2&gt;Complexity Analysis&lt;/h2&gt;\n&lt;p&gt;Since we split apart $\\text{edge list}$ into two disjoint groups $\\text{G}1$ and $\\text{G}2$ in every call $f(l, r, \\text{edge list})$, this ensures that every edge occurs exactly once on every level of the recursion. For every call $f(l, r, \\text{edge list})$, we perform a $O(\\vert \\text{edge list} \\vert)$ computation. So on every level, we perform a $O(\\sum_{f(l, r, \\text{edge list})}(\\vert \\text{edge list} \\vert)) = O(m)$ computation. There are $\\log_2(m)$ levels of the recursion, so our pre-processing algorithm works in $O(m \\log_2{m})$.&lt;/p&gt;\n&lt;p&gt;The time taken for answering queries is problem dependent.&lt;/p&gt;\n&lt;h2&gt;Example Problems&lt;/h2&gt;\n&lt;h3&gt;1. &lt;a href=\&quot;https://qoj.ac/contest/796/problem/2214?v=1\&quot;&gt;Problem L, Grand Prix of Zheijang (Open Cup 2018-19)&lt;/a&gt;&lt;/h3&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Solution&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\nTrivial, just use DSU to maintain size of each SCC.\n&lt;/div&gt;\n&lt;/details&gt;\n&lt;h3&gt;2. &lt;a href=\&quot;https://codeforces.com/problemset/problem/1989/F\&quot;&gt;CF-1989F&lt;/a&gt;&lt;/h3&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Solution&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\nTo be updated\n&lt;/div&gt;\n&lt;/details&gt;\n&lt;h3&gt;3. &lt;a href=\&quot;https://www.acmicpc.net/problem/8496\&quot;&gt;ONTAK 2009 Godzilla&lt;/a&gt;&lt;/h3&gt;\n&lt;details&gt;&lt;summary class =\&quot;spoiler-summary\&quot;&gt;Solution&lt;/summary&gt;\n&lt;div class = \&quot;spoiler-content\&quot;&gt;\nTo be updated\n&lt;/div&gt;\n&lt;/details&gt;\n&quot;],&quot;ssrFrontmatter&quot;:[0,{&quot;displayMode&quot;:[0,&quot;blog&quot;],&quot;title&quot;:[0,&quot;Offline Incremental SCC&quot;],&quot;date&quot;:[0,&quot;2024-07-29&quot;],&quot;tags&quot;:[1,[[0,&quot;algorithm&quot;]]]}],&quot;ssrFlags&quot;:[0,{&quot;isBlog&quot;:[0,true],&quot;isMusings&quot;:[0,false]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;ContentPane&quot;,&quot;value&quot;:true}" await-children><!--[--><!--[!--><!--[1--><div class="h-full w-full bg-cover bg-center bg-no-repeat" style="background-image: url('/_astro/expoutput-1500w.BYFb0Fuh.webp');"></div><!--]--><!--]--><!--]--><!--astro:end--></astro-island> </main> <!-- Terminal --> <aside class="border-t border-zinc-700 md:border-t-0 md:border-l md:border-zinc-700 order-1 md:order-none"> <astro-island uid="1NBGTk" component-url="/_astro/TerminalPane.DRvAhnyr.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;TerminalPane&quot;,&quot;value&quot;:true}" await-children><!--[--><div class="h-full flex flex-col bg-zinc-900 desktop-wrapper svelte-twihms"><div class="md:hidden flex items-center justify-between px-3 py-2 border-b border-zinc-700"><span class="font-mono text-xs text-zinc-400">terminal</span> <button class="text-zinc-300" aria-label="Toggle terminal"><!--[!-->▲<!--]--></button></div> <!--[1--><button class="desktop-toggle hidden md:flex svelte-twihms" aria-label="Collapse terminal">▶</button><!--]--> <div class="flex-1 overflow-hidden"><div class="terminal-content body svelte-twihms"><div class="terminal-shell h-full w-full svelte-1asehid focused"></div><!----></div></div></div><!--]--><!--astro:end--></astro-island> </aside> </div> </body></html>