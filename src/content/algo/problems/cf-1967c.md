---
displayMode: blog
title: CF-1967C
date: 2025-09-04
tags: [editorial]
---

This is a very easy problem but it did serve as a good exposition for intuition on a couple of ideas for me.

### Problem [CF-1967C](https://codeforces.com/problemset/problem/1967/C)

### Statement

> Let **lowbit**$(x)$ denote the value of the lowest binary bit of $x$, e.g.  
$\operatorname{lowbit}(12)=4$, $\operatorname{lowbit}(8)=8$.
> 
> For an array $a$ of length $n$, define an array $s$ of length $n$ by  
$$
s_k \equiv \left(\sum_{i = k - \operatorname{lowbit}(k) + 1}^{k} a_i \right) \bmod 998244353 \quad \text{for all } k,
$$  
> and call $s$ the **Fenwick Tree** of $a$. Letâ€™s denote it as $s = f(a)$.
> 
> For a positive integer $k$ and an array $a$, define $f^{k}(a)$ recursively as  
> $$
> f^{k}(a) =
> \begin{cases}
> f(a), & \text{if } k = 1, \\
> f(f^{k-1}(a)), & \text{otherwise.}
> \end{cases}
> $$
> 
> You are given an array $b$ of length $n$ and a positive integer $k$.  
> Find an array $a$ that satisfies $0 \le a_i < 998244353$ and $f^{k}(a) = b$.  
> 
> It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.


Constraints:

- $1 \leq n \leq 2 \cdot 10^5$
- $1 \leq k \leq 10^9$
- $0 \le b_i < 998244353$

### Solution

Firstly, it's time for me to admit that I never really bothered to learn how a fenwick tree internally works, due to almost always having preferred segment trees over them (only using the former as a blackbox when trying to squeeze one of my cursed $O(n \sqrt{n} \log{n})$ implementations into the TL). Knowing this, the reader shall excuse me for spending some time understanding what's going on with $\operatorname{lowbit}(x)$.

Let's define $\operatorname{lsb}(x) = \log_2 (\operatorname{lowbit}(x))$ for convenience.

So, what does the sequence $\operatorname{lowbit}(x)$ even look like? It takes the following form:

> 1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16 ...

Clearly, $\operatorname{lowbit}(x)$ is simply the greatest power of 2 that divides $x$, and any value of $\operatorname{lowbit}(x)$, say $d$, repeats with a period of $d$ save for places where it gets "overridden" by greater values of $d$.

Now, what form do the segments mentioned in the problem $[i - \operatorname{lowbit}(i) + 1]$ take?

<div style="text-align:center"><img src="/assets/cf-1967c/img1.png"/></div>

It isn't difficult to see that this structure is essentially just half a segment tree (to be more specific, it is what we would be left with upon deleting the segment corresponding to the right child of every node).

Here's an illustration that should make this clearer. The blue nodes (and their corresponding ranges) are the ones present in our structure, while the red ones aren't.

<div style="text-align:center"><img src="/assets/cf-1967c/img2.png"/></div>

Let's give this thing a name, we'll call it a ghost segment tree (after the red ghost nodes/segments).

What are some useful properties of this structure?

1. For all $i$, $\operatorname{lowbit}(j) = \operatorname{lowbit}(i -  \operatorname{lowbit}(i) + j)$ for $1 \leq j \leq \operatorname{lowbit}(i)$. This simplifies analysis by a great deal, as we now need to only concern ourselves with prefixes of the $\operatorname{lowbit}(i)$ that have lengths which are some powers of two.
2. Let's define $C(i)$ as the set of all $j$ where $j - \operatorname{lowbit}(j) + 1 \leq i \leq j$. Then $\operatorname{lowbit}(j_1) \neq \operatorname{lowbit}(j_2) \quad \forall \quad j_1, j_2 \in C(i) : j_1 \neq j_2$.

How do these properties help us? Consider the first property, it implies that no matter what $i$ we choose, the minimal "subtree" of this "ghost segment tree" that contains the segment $[i - \operatorname{lowbit}(i) + 1, i]$ will conveniently be isomorphic to the minimal subtree over the segment $[1, \operatorname{lowbit}(i)]$. This is extremely convenient because we now know that for any $i$, the minimal subtree containing its segment is going to be a perfect binary tree of height $\operatorname{lsb}(i)$ (well, as perfect as it can get with half of its node being ghost nodes, but you get the point), and we can use properties implied from this symmetry to design efficient algorithms.

Another useful property is that the leaf node corresponding to $i$ is the rightmost leaf in the minimal subtree on segment $[i - \operatorname{lowbit}(i) + 1, i]$.

For instance, let's consider finding the sum over $[i - \operatorname{lowbit}(i) + 1, i]$ for all $i \leq n$. Assume $n = 8$, and look at the diagram above again.

A simple way to do this is the following:

- We compute $x(i) = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i} a_j$ in increasing order of $i$.
- We compute $x(i)$ in the following manner:
    - We begin at $v = $ the leaf node corresponding to $i$, with $x(i) = a_i$.
    - Until $v \neq r$, where $r$ is the root node of the minimal subtree containing $[i - \operatorname{lowbit}(i) + 1, i]$:
        - Set $v$ to the parent of $v$.
        - Let $\text{lc}$ be the rightmost leaf in the subtree of the left child of $v$. Add $x(\text{lc})$ to $x(i)$. 

It's easy to see that this is valid because the rightmost leaf in any subtree corresponds to a segment that covers all the leaf nodes in that subtree. This algorithm takes $O(n \log {n})$ time, as we traverse to $v$'s parent at most $O(\log {n})$ times for each $i$.

Let's return to the original problem and try to use some of the ideas we've consolidated. 

Firstly, let's introduce a natural setup that's equivalent to the one in the problem:
- We begin with some unknown sequence $a(0)$ of length $n$ at time $t = 0$.
- At time $t = x$, we create a new sequence $a(x)$ (also of length $n$), which is defined in the following manner: $a(t)_i = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i} a(t - 1)_j$
- We're given $a(k)$ and asked to recover $a(0)$.

Since lesser indices affect larger indices, it's reasonable to try and recover the original values of the sequence in increasing order of $i$.

So, what about the first element? Well its segment is $[1, 1]$ and it will therefore remain constant across all sequences, implying $a(0)_1 = a(k)_1$. More generally, $a(0)_i = a(k)_i \forall i : \operatorname{lowbit}(i) = 1$.

A natural question that arises is: What about $i$ with $\operatorname{lowbit}(i) = 2$? These have the segment $[i - 1, i]$, and since it's guaranteed that $\operatorname{lowbit}(i - 1) = 1$, we obtain $a(t)_i = a(0)_i + t \cdot a(0)_{i - 1}$.

Things start getting much more complicated if one attempts to analyse greater values of $\operatorname{lowbit}(i)$ in this manner, and this prompts us to take a more systematic approach and actually understand what's going on here.

Let's consider 