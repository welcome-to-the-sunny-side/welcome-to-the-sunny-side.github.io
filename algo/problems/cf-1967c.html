<!DOCTYPE html><html lang="en" class="h-full"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Welcome to the Sunny Side!</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDGES615HV"></script><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-FDGES615HV");</script><script type="module">
    import { currentSkin } from '/src/stores/skin.ts';
    currentSkin.subscribe((skin) => {
      const rootCls = `h-full bg-bg text-text ${skin.classes.body}`;
      document.documentElement.className = rootCls;
      document.body.className = rootCls;
      // set CSS variables on :root
      const rs = document.documentElement.style;
      Object.entries(skin.cssVars).forEach(([k,v]) => rs.setProperty(`--${k}`, v));
      if (skin.inlineStyles?.body) {
        Object.assign(document.body.style, skin.inlineStyles.body);
      }
    });
  </script><link rel="stylesheet" href="/_astro/_slug_.B_lpCp7p.css"></head> <body class="h-full"> <div class="h-screen w-screen grid grid-cols-1 md:grid-cols-[1fr_auto] grid-rows-[auto_1fr] md:grid-rows-1"> <!-- Content --> <main class="overflow-y-auto overflow-x-hidden order-2 md:order-none bg-surface text-text transition-colors duration-150 ease-retro"> <div id="ssr-fallback" class="p-4 prose prose-invert max-w-none"><p>This is a very easy problem but it did serve as a good way to build intuition on a couple of ideas for me.</p>
<h3>Problem <a href="https://codeforces.com/problemset/problem/1967/C">CF-1967C</a></h3>
<h3>Statement</h3>
<blockquote>
<p>Let $\operatorname{lowbit}(x)$ denote the value of the lowest binary bit of $x$, e.g.<br>
$\operatorname{lowbit}(12)=4$, $\operatorname{lowbit}(8)=8$.</p>
<p>For an array $a$ of length $n$, define an array $s$ of length $n$ by<br>
$$
s_k \equiv \left(\sum_{i = k - \operatorname{lowbit}(k) + 1}^{k} a_i \right) \bmod 998244353 \quad \text{for all } k,
$$<br>
and call $s$ the <strong>Fenwick Tree</strong> of $a$. Letâ€™s denote it as $s = f(a)$.</p>
<p>For a positive integer $k$ and an array $a$, define $f^{k}(a)$ recursively as<br>
$$ f^{k}(a) = \begin{cases} f(a), & \text{if } k = 1, \\ f(f^{k-1}(a)), & \text{otherwise.} \end{cases} $$</p>
<p>You are given an array $b$ of length $n$ and a positive integer $k$.<br>
Find an array $a$ that satisfies $0 \le a_i < 998244353$ and $f^{k}(a) = b$.</p>
<p>It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.</p>
</blockquote>
<p>Constraints:</p>
<ul>
<li>$1 \leq n \leq 2 \cdot 10^5$</li>
<li>$1 \leq k \leq 10^9$</li>
<li>$0 \le b_i < 998244353$</li>
</ul>
<h3>Solution</h3>
<p>Firstly, it's time for me to admit that I never really bothered to learn how a fenwick tree internally works, due to almost always having preferred segment trees over them (only using them as a blackbox when trying to squeeze one of my cursed $O(n \sqrt{n} \log{n})$ implementations into the TL). Knowing this, the reader shall excuse me for spending some time understanding what's going on with $\operatorname{lowbit}(x)$.</p>
<p>Let's define $\operatorname{lsb}(x) = \log_2 (\operatorname{lowbit}(x))$ for convenience.</p>
<p>So, what does the sequence $\operatorname{lowbit}(x)$ even look like? It takes the following form:</p>
<blockquote>
<p>1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16 ...</p>
</blockquote>
<p>Clearly, $\operatorname{lowbit}(x)$ is simply the greatest power of 2 that divides $x$, and any value of $\operatorname{lowbit}(x)$, say $d$, repeats with a period of $d$ save for places where it gets &quot;overridden&quot; by greater values of $d$.</p>
<p>Now, what form do the segments $[i - \operatorname{lowbit}(i) + 1, i]$ take?</p>
<div style="text-align:center"><img src="/assets/cf-1967c/img1.png"/></div>
<p>It isn't difficult to see that this structure is essentially just half a segment tree (to be more specific, it is what we would be left with upon deleting the segment corresponding to the right child of every node).</p>
<p>Here's an illustration that should make this clearer. The blue nodes (and their corresponding ranges) are the ones present in our structure, while the red ones aren't.</p>
<div style="text-align:center"><img src="/assets/cf-1967c/img2.png"/></div>
<p>Let's give this thing a name, we'll call it a ghost segment tree (after the red ghost nodes/segments).</p>
<p>What are some useful properties of this structure?</p>
<ol>
<li>For all $i$, $\operatorname{lowbit}(j) = \operatorname{lowbit}(i -  \operatorname{lowbit}(i) + j)$ for $1 \leq j \leq \operatorname{lowbit}(i)$. This simplifies analysis by a great deal, as we now need to only concern ourselves with prefixes of the $\operatorname{lowbit}(i)$ that have lengths which are some powers of two.</li>
<li>Let's define $\operatorname{cover}(i)$ as the set of all $j$ where $j - \operatorname{lowbit}(j) + 1 \leq i \leq j$. Then $\operatorname{lowbit}(j_1) \neq \operatorname{lowbit}(j_2) \quad \forall \quad j_1, j_2 \in \operatorname{cover}(i) : j_1 \neq j_2$.</li>
</ol>
<p>How do these properties help us? Consider the first property, it implies that no matter what $i$ we choose, the minimal &quot;subtree&quot; of this &quot;ghost segment tree&quot; that contains the segment $[i - \operatorname{lowbit}(i) + 1, i]$ will conveniently be isomorphic to the minimal subtree over the segment $[1, \operatorname{lowbit}(i)]$. This is extremely convenient because we now know that for any $i$, the minimal subtree containing its segment is going to be a perfect binary tree of height $\operatorname{lsb}(i)$ (well, as perfect as it can get with half of its nodes being ghost nodes, but you get the point), and we can use properties implied from this symmetry to design efficient algorithms.</p>
<p>Another useful property is that the leaf node corresponding to $i$ is the rightmost leaf in the minimal subtree on segment $[i - \operatorname{lowbit}(i) + 1, i]$.</p>
<p>For instance, let's consider finding the sum over $[i - \operatorname{lowbit}(i) + 1, i]$ for all $i \leq n$. Assume $n = 8$, and look at the diagram above again.</p>
<p>A simple way to do this is the following:</p>
<ul>
<li>We compute $x(i) = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i} a_j$ in increasing order of $i$.</li>
<li>We compute $x(i)$ in the following manner:
<ul>
<li>We begin at $v = $ the leaf node corresponding to $i$, with $x(i) = a_i$.</li>
<li>Until $v \neq r$, where $r$ is the root node of the minimal subtree containing $[i - \operatorname{lowbit}(i) + 1, i]$:
<ul>
<li>Set $v$ to the parent of $v$.</li>
<li>Let $\text{lc}$ be the rightmost leaf in the subtree of the left child of $v$. Add $x(\text{lc})$ to $x(i)$.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>It's easy to see that this is valid because the rightmost leaf in any subtree corresponds to a segment that covers all the leaf nodes in that subtree. This algorithm takes $O(n \log {n})$ time, as we traverse to $v$'s parent at most $O(\log {n})$ times for each $i$.</p>
<p>For the sake of brevity in the coming sections, we define $C(i)$ to be the set of all $\text{lc}$ that we touch when we run this algorithm for $i$.</p>
<p>Let's return to the original problem and try to use some of the ideas we've consolidated. Computations ahead are modulo $998244353$ wherever applicable.</p>
<p>Firstly, let's introduce a natural setup that's equivalent to the one in the problem:</p>
<ul>
<li>We begin with some unknown sequence $a(0)$ of length $n$ at time $t = 0$.</li>
<li>At time $t$, we create a new sequence $a(t)$ (also of length $n$), which is defined in the following manner: $a(t)_i = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i} a(t - 1)_j$</li>
<li>We're given $a(k)$ and asked to recover $a(0)$.</li>
</ul>
<p>Since smaller indices directionally affect larger indices, it's reasonable to try and recover the original values of the sequence in increasing order of $i$.</p>
<p>So, what about the first element? Well its segment is $[1, 1]$ and it will therefore remain constant across all sequences, implying $a(0)_1 = a(k)_1$. More generally, $a(0)_i = a(t)_1 =  a(k)_i \forall i : \operatorname{lowbit}(i) = 1$.</p>
<p>A natural question that now rears its head: What about $i$ with $\operatorname{lowbit}(i) = 2$? These have the segment $[i - 1, i]$, and since it's guaranteed that $\operatorname{lowbit}(i - 1) = 1$, we obtain $a(t)_i = a(0)_i + t \cdot a(0)_{i - 1} \implies a(0)_i = a(k)_i - k \cdot a(0)_{i - 1}$</p>
<p>Things start getting much more complicated if one attempts to analyse greater values of $\operatorname{lowbit}(i)$ in this manner, and this prompts us to take a more systematic approach and actually understand what's going on here.</p>
<p>Let's study $i = \operatorname{lowbit}(i) = 8$. We assume that we've already computed all $a(0)_j : j < i$ by the time we reach $i$.</p>
<div style="text-align:center"><img src="/assets/cf-1967c/img3.png"/></div>
<p>Using previously developed intuition, we notice that $a(t)_i = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i} a(t - 1)_j = a(t - 1)_i + \sum_{j \in C(i)} a(t)_j$. Does this even help us? There seems to be no immediately noticeable advantage but let's trudge on, keeping this in mind.</p>
<p>Now, it's apparent that $a(t)_i$ is going to be some linear combination of $a(0)_j$ (where $j \in [i - \operatorname{lowbit}(i) + 1, i]$), but the coefficients in that linear combination do not reveal themselves to us so easily. Let's just define $a(t)_i$ in this manner as $\sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i}{\operatorname{coeff}(t, i, j) \cdot a(0)_j}$. Trivially, $\operatorname{coeff}(t, i, i) = 1$.</p>
<p>Let's consider $p = 3$, what could $\operatorname{coeff}(t, i, p)$ possibly be? If we go back to our alternate definition, ie. $a(t)_i = a(0)_i + \sum_{j \in C(i)} a(t)_j$, we can see that the only $j \in C(i)$ that's relevant to $\operatorname{coeff}(t, i, p)$ is $4$, and if we rewrite $a(t)_4$ as $\sum_{1 \leq j \leq 4}{\operatorname{coeff}(t, 4, j) \cdot a(0)_j}$, we realise that at every second, we add $\operatorname{coeff}(t, 4, 3)$ to $\operatorname{coeff} (t, 8, 3)$ (and these gains carry over into the future), so we simply have $\operatorname{coeff}(t, 8, 3) = \sum_{1 \leq k \leq t} \operatorname{coeff}(k, 4, 3)$.</p>
<p>What about $\operatorname{coeff}(t, 4, 3)$? Well, if we consider $C(4)$, we realize that it's built directly from contributions by the node $3$ itself, and it turns out to be $\operatorname{coeff}(t, 4, 3) = \sum_{1 \leq k \leq t} \operatorname{coeff}(k, 3, 3)$.</p>
<p>There's a clear pattern being revealed here, and it takes the following form:</p>
<ul>
<li>To find $\operatorname{coeff}(t, i, j)$:
<ul>
<li>If $j = i$, then it's trivially defined as $\operatorname{coeff}(t, i, i) = 1$.</li>
<li>Otherwise, start with $k = i$ and sequence $S = [i]$ and run the following algorithm until you reach $k = j$:
<ul>
<li>There will be exactly one $y \in C(k)$ such that $j \in [y - \operatorname{lowbit}(y) + 1, y]$, set $k = y$. Append $k$ to $S$.</li>
</ul>
</li>
<li>Now, it's not difficult to observe that for every element $k$ in $S$ except the last (which is $j$), all of its contributions to $\operatorname{coeff}(t, k, j)$ are made solely by the next element $k_2$. To be more precise $\operatorname{coeff}(t, k, j) = \sum_{1 \leq l \leq t} \operatorname{coeff}(l, k_2, j)$.</li>
<li>Clearly, this process is equivalent to starting off with an identity sequence, and at every iteration, replacing the current sequence with its prefix sum sequence, $\vert S \vert - 1$ times. The final sequence is going to be $\operatorname{coeff}(t, i, j)$. Since only the size of $S$ is important, let's define $S(i, j) = \vert S \vert - 1$. Note that $S(i, j) \leq \lceil \log_2{n} \rceil$ (actually, $S(i, j) = \operatorname{popcount}(i - j)$ but let's not get into that).</li>
</ul>
</li>
<li>Using some combinatorics, we can derive the resultant sequence, and it's: $\operatorname{coeff}(t, i, j) = \frac{t(t + 1) \dots (t + S(i, j) - 1)}{S(i, j)!}$. Since this value depends solely on $t$ and $S(i, j)$, let's define $\operatorname{coeff2} (t, s) = \frac{t(t + 1) \dots (t + s - 1)}{s!}$.</li>
</ul>
<p>I understand that the iterative process that generates $S$ may feel a bit arbitrary/unmotivated, so here's a visual which shows the values of $k$ that we touch when generating $S$ for $i = 16, j = 3$:</p>
<div style="text-align:center"><img src="/assets/cf-1967c/img4.png"/></div>
<p>$\operatorname{coeff}(t, i, j)$ depending solely on $t$ and $S(i, j)$, motivates: $$a(t)_i = \sum_{i - \operatorname{lowbit}(i) + 1 \leq j \leq i}{\operatorname{coeff}(t, i, j) \cdot a(0)_j} = \sum_{c \leq \lceil \log_2{n} \rceil} (\operatorname{coeff2}(t, c) \cdot \sum_{j : S(i, j) = c} a(0)_j)$$</p>
<p>All that remains is to find an efficient way to compute $\sum_{j : S(i, j) = c} a(0)_j$ for all $c \leq \lceil \log_2{n} \rceil$ in the relevant range (we can just precompute the $O(\log{n})$ required values of $\operatorname{coeff2}(t, c)$).</p>
<p>Consider any $i$ and $j \in [i - \operatorname{lowbit}(i) + 1, i]$. There's a unique element $y \in C(i)$ for which $j \in [y - \operatorname{lowbit}(y) + 1, y]$. It's easy to see that $S(i, j) = S(y, j) + 1$, so the contribution to $\sum_{j : S(i, j) = c} a(0)_j$ from elements in $[y - \operatorname{lowbit}(y) + 1, y]$ for $y \in C(i)$ is going to be $\sum_{j : S(y, j) = c - 1} a(0)_j$, and at long last, we have an efficient formulation for $\sum_{j : S(i, j) = c} a(0)_j$:</p>
<p>$$\sum_{j : S(i, j) = c} a(0)_j = \sum_{y \in C(i)} \sum_{j : S(y, j) = c - 1} a(0)_j$$</p>
<p>(this is efficient because $\vert C(i) \vert \leq \lceil \log_2{n} \rceil$)</p>
<p>The final solution takes the following form:</p>
<pre class="hljs"><code>L = ceil(log2(n))
coeff2_t[L + 1] #compute this in whatever manner you'd like

a_0[n + 1]      #initial values (to be recovered)
a_t[n + 1]      #final values (at time t)
dp[n + 1][L + 1]    #dp[i][c] = sum(a_0[j]) for j : S(i, j) = c

for i from 1 to n:
    compute C(i) in O(log(n))
    for y in C(i)
        for c from 1 to L
            dp[i][c] += dp[y][c - 1]

    a_0[i] = a_t[i]
    for c from 1 to L
        a_0[i] -= dp[i][c] * coeff2_t[c]

    dp[i][0] = a_0[i]
</code></pre>
<p>This clearly runs in $O(n \log^2{n})$ and that's fast enough to fit within the TL (although a $O(n \log{n})$ solution exists).</p>
<p>I suck at explaining things in a concise manner, but it's probably just a result of sucking at thinking about things in a concise manner.</p>
</div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="ZsW0NO" component-url="/_astro/ContentPane.CWksgNm-.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{&quot;ssrPath&quot;:[0,&quot;/algo/problems/cf-1967c.html&quot;],&quot;ssrHtml&quot;:[0,&quot;&lt;p&gt;This is a very easy problem but it did serve as a good way to build intuition on a couple of ideas for me.&lt;/p&gt;\n&lt;h3&gt;Problem &lt;a href=\&quot;https://codeforces.com/problemset/problem/1967/C\&quot;&gt;CF-1967C&lt;/a&gt;&lt;/h3&gt;\n&lt;h3&gt;Statement&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Let $\\operatorname{lowbit}(x)$ denote the value of the lowest binary bit of $x$, e.g.&lt;br&gt;\n$\\operatorname{lowbit}(12)=4$, $\\operatorname{lowbit}(8)=8$.&lt;/p&gt;\n&lt;p&gt;For an array $a$ of length $n$, define an array $s$ of length $n$ by&lt;br&gt;\n$$\ns_k \\equiv \\left(\\sum_{i = k - \\operatorname{lowbit}(k) + 1}^{k} a_i \\right) \\bmod 998244353 \\quad \\text{for all } k,\n$$&lt;br&gt;\nand call $s$ the &lt;strong&gt;Fenwick Tree&lt;/strong&gt; of $a$. Letâ€™s denote it as $s = f(a)$.&lt;/p&gt;\n&lt;p&gt;For a positive integer $k$ and an array $a$, define $f^{k}(a)$ recursively as&lt;br&gt;\n$$ f^{k}(a) = \\begin{cases} f(a), &amp; \\text{if } k = 1, \\\\ f(f^{k-1}(a)), &amp; \\text{otherwise.} \\end{cases} $$&lt;/p&gt;\n&lt;p&gt;You are given an array $b$ of length $n$ and a positive integer $k$.&lt;br&gt;\nFind an array $a$ that satisfies $0 \\le a_i &lt; 998244353$ and $f^{k}(a) = b$.&lt;/p&gt;\n&lt;p&gt;It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Constraints:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;$1 \\leq n \\leq 2 \\cdot 10^5$&lt;/li&gt;\n&lt;li&gt;$1 \\leq k \\leq 10^9$&lt;/li&gt;\n&lt;li&gt;$0 \\le b_i &lt; 998244353$&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Solution&lt;/h3&gt;\n&lt;p&gt;Firstly, it&#39;s time for me to admit that I never really bothered to learn how a fenwick tree internally works, due to almost always having preferred segment trees over them (only using them as a blackbox when trying to squeeze one of my cursed $O(n \\sqrt{n} \\log{n})$ implementations into the TL). Knowing this, the reader shall excuse me for spending some time understanding what&#39;s going on with $\\operatorname{lowbit}(x)$.&lt;/p&gt;\n&lt;p&gt;Let&#39;s define $\\operatorname{lsb}(x) = \\log_2 (\\operatorname{lowbit}(x))$ for convenience.&lt;/p&gt;\n&lt;p&gt;So, what does the sequence $\\operatorname{lowbit}(x)$ even look like? It takes the following form:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16 ...&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Clearly, $\\operatorname{lowbit}(x)$ is simply the greatest power of 2 that divides $x$, and any value of $\\operatorname{lowbit}(x)$, say $d$, repeats with a period of $d$ save for places where it gets &amp;quot;overridden&amp;quot; by greater values of $d$.&lt;/p&gt;\n&lt;p&gt;Now, what form do the segments $[i - \\operatorname{lowbit}(i) + 1, i]$ take?&lt;/p&gt;\n&lt;div style=\&quot;text-align:center\&quot;&gt;&lt;img src=\&quot;/assets/cf-1967c/img1.png\&quot;/&gt;&lt;/div&gt;\n&lt;p&gt;It isn&#39;t difficult to see that this structure is essentially just half a segment tree (to be more specific, it is what we would be left with upon deleting the segment corresponding to the right child of every node).&lt;/p&gt;\n&lt;p&gt;Here&#39;s an illustration that should make this clearer. The blue nodes (and their corresponding ranges) are the ones present in our structure, while the red ones aren&#39;t.&lt;/p&gt;\n&lt;div style=\&quot;text-align:center\&quot;&gt;&lt;img src=\&quot;/assets/cf-1967c/img2.png\&quot;/&gt;&lt;/div&gt;\n&lt;p&gt;Let&#39;s give this thing a name, we&#39;ll call it a ghost segment tree (after the red ghost nodes/segments).&lt;/p&gt;\n&lt;p&gt;What are some useful properties of this structure?&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;For all $i$, $\\operatorname{lowbit}(j) = \\operatorname{lowbit}(i -  \\operatorname{lowbit}(i) + j)$ for $1 \\leq j \\leq \\operatorname{lowbit}(i)$. This simplifies analysis by a great deal, as we now need to only concern ourselves with prefixes of the $\\operatorname{lowbit}(i)$ that have lengths which are some powers of two.&lt;/li&gt;\n&lt;li&gt;Let&#39;s define $\\operatorname{cover}(i)$ as the set of all $j$ where $j - \\operatorname{lowbit}(j) + 1 \\leq i \\leq j$. Then $\\operatorname{lowbit}(j_1) \\neq \\operatorname{lowbit}(j_2) \\quad \\forall \\quad j_1, j_2 \\in \\operatorname{cover}(i) : j_1 \\neq j_2$.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;How do these properties help us? Consider the first property, it implies that no matter what $i$ we choose, the minimal &amp;quot;subtree&amp;quot; of this &amp;quot;ghost segment tree&amp;quot; that contains the segment $[i - \\operatorname{lowbit}(i) + 1, i]$ will conveniently be isomorphic to the minimal subtree over the segment $[1, \\operatorname{lowbit}(i)]$. This is extremely convenient because we now know that for any $i$, the minimal subtree containing its segment is going to be a perfect binary tree of height $\\operatorname{lsb}(i)$ (well, as perfect as it can get with half of its nodes being ghost nodes, but you get the point), and we can use properties implied from this symmetry to design efficient algorithms.&lt;/p&gt;\n&lt;p&gt;Another useful property is that the leaf node corresponding to $i$ is the rightmost leaf in the minimal subtree on segment $[i - \\operatorname{lowbit}(i) + 1, i]$.&lt;/p&gt;\n&lt;p&gt;For instance, let&#39;s consider finding the sum over $[i - \\operatorname{lowbit}(i) + 1, i]$ for all $i \\leq n$. Assume $n = 8$, and look at the diagram above again.&lt;/p&gt;\n&lt;p&gt;A simple way to do this is the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;We compute $x(i) = \\sum_{i - \\operatorname{lowbit}(i) + 1 \\leq j \\leq i} a_j$ in increasing order of $i$.&lt;/li&gt;\n&lt;li&gt;We compute $x(i)$ in the following manner:\n&lt;ul&gt;\n&lt;li&gt;We begin at $v = $ the leaf node corresponding to $i$, with $x(i) = a_i$.&lt;/li&gt;\n&lt;li&gt;Until $v \\neq r$, where $r$ is the root node of the minimal subtree containing $[i - \\operatorname{lowbit}(i) + 1, i]$:\n&lt;ul&gt;\n&lt;li&gt;Set $v$ to the parent of $v$.&lt;/li&gt;\n&lt;li&gt;Let $\\text{lc}$ be the rightmost leaf in the subtree of the left child of $v$. Add $x(\\text{lc})$ to $x(i)$.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;It&#39;s easy to see that this is valid because the rightmost leaf in any subtree corresponds to a segment that covers all the leaf nodes in that subtree. This algorithm takes $O(n \\log {n})$ time, as we traverse to $v$&#39;s parent at most $O(\\log {n})$ times for each $i$.&lt;/p&gt;\n&lt;p&gt;For the sake of brevity in the coming sections, we define $C(i)$ to be the set of all $\\text{lc}$ that we touch when we run this algorithm for $i$.&lt;/p&gt;\n&lt;p&gt;Let&#39;s return to the original problem and try to use some of the ideas we&#39;ve consolidated. Computations ahead are modulo $998244353$ wherever applicable.&lt;/p&gt;\n&lt;p&gt;Firstly, let&#39;s introduce a natural setup that&#39;s equivalent to the one in the problem:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;We begin with some unknown sequence $a(0)$ of length $n$ at time $t = 0$.&lt;/li&gt;\n&lt;li&gt;At time $t$, we create a new sequence $a(t)$ (also of length $n$), which is defined in the following manner: $a(t)_i = \\sum_{i - \\operatorname{lowbit}(i) + 1 \\leq j \\leq i} a(t - 1)_j$&lt;/li&gt;\n&lt;li&gt;We&#39;re given $a(k)$ and asked to recover $a(0)$.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Since smaller indices directionally affect larger indices, it&#39;s reasonable to try and recover the original values of the sequence in increasing order of $i$.&lt;/p&gt;\n&lt;p&gt;So, what about the first element? Well its segment is $[1, 1]$ and it will therefore remain constant across all sequences, implying $a(0)_1 = a(k)_1$. More generally, $a(0)_i = a(t)_1 =  a(k)_i \\forall i : \\operatorname{lowbit}(i) = 1$.&lt;/p&gt;\n&lt;p&gt;A natural question that now rears its head: What about $i$ with $\\operatorname{lowbit}(i) = 2$? These have the segment $[i - 1, i]$, and since it&#39;s guaranteed that $\\operatorname{lowbit}(i - 1) = 1$, we obtain $a(t)_i = a(0)_i + t \\cdot a(0)_{i - 1} \\implies a(0)_i = a(k)_i - k \\cdot a(0)_{i - 1}$&lt;/p&gt;\n&lt;p&gt;Things start getting much more complicated if one attempts to analyse greater values of $\\operatorname{lowbit}(i)$ in this manner, and this prompts us to take a more systematic approach and actually understand what&#39;s going on here.&lt;/p&gt;\n&lt;p&gt;Let&#39;s study $i = \\operatorname{lowbit}(i) = 8$. We assume that we&#39;ve already computed all $a(0)_j : j &lt; i$ by the time we reach $i$.&lt;/p&gt;\n&lt;div style=\&quot;text-align:center\&quot;&gt;&lt;img src=\&quot;/assets/cf-1967c/img3.png\&quot;/&gt;&lt;/div&gt;\n&lt;p&gt;Using previously developed intuition, we notice that $a(t)_i = \\sum_{i - \\operatorname{lowbit}(i) + 1 \\leq j \\leq i} a(t - 1)_j = a(t - 1)_i + \\sum_{j \\in C(i)} a(t)_j$. Does this even help us? There seems to be no immediately noticeable advantage but let&#39;s trudge on, keeping this in mind.&lt;/p&gt;\n&lt;p&gt;Now, it&#39;s apparent that $a(t)_i$ is going to be some linear combination of $a(0)_j$ (where $j \\in [i - \\operatorname{lowbit}(i) + 1, i]$), but the coefficients in that linear combination do not reveal themselves to us so easily. Let&#39;s just define $a(t)_i$ in this manner as $\\sum_{i - \\operatorname{lowbit}(i) + 1 \\leq j \\leq i}{\\operatorname{coeff}(t, i, j) \\cdot a(0)_j}$. Trivially, $\\operatorname{coeff}(t, i, i) = 1$.&lt;/p&gt;\n&lt;p&gt;Let&#39;s consider $p = 3$, what could $\\operatorname{coeff}(t, i, p)$ possibly be? If we go back to our alternate definition, ie. $a(t)_i = a(0)_i + \\sum_{j \\in C(i)} a(t)_j$, we can see that the only $j \\in C(i)$ that&#39;s relevant to $\\operatorname{coeff}(t, i, p)$ is $4$, and if we rewrite $a(t)_4$ as $\\sum_{1 \\leq j \\leq 4}{\\operatorname{coeff}(t, 4, j) \\cdot a(0)_j}$, we realise that at every second, we add $\\operatorname{coeff}(t, 4, 3)$ to $\\operatorname{coeff} (t, 8, 3)$ (and these gains carry over into the future), so we simply have $\\operatorname{coeff}(t, 8, 3) = \\sum_{1 \\leq k \\leq t} \\operatorname{coeff}(k, 4, 3)$.&lt;/p&gt;\n&lt;p&gt;What about $\\operatorname{coeff}(t, 4, 3)$? Well, if we consider $C(4)$, we realize that it&#39;s built directly from contributions by the node $3$ itself, and it turns out to be $\\operatorname{coeff}(t, 4, 3) = \\sum_{1 \\leq k \\leq t} \\operatorname{coeff}(k, 3, 3)$.&lt;/p&gt;\n&lt;p&gt;There&#39;s a clear pattern being revealed here, and it takes the following form:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;To find $\\operatorname{coeff}(t, i, j)$:\n&lt;ul&gt;\n&lt;li&gt;If $j = i$, then it&#39;s trivially defined as $\\operatorname{coeff}(t, i, i) = 1$.&lt;/li&gt;\n&lt;li&gt;Otherwise, start with $k = i$ and sequence $S = [i]$ and run the following algorithm until you reach $k = j$:\n&lt;ul&gt;\n&lt;li&gt;There will be exactly one $y \\in C(k)$ such that $j \\in [y - \\operatorname{lowbit}(y) + 1, y]$, set $k = y$. Append $k$ to $S$.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Now, it&#39;s not difficult to observe that for every element $k$ in $S$ except the last (which is $j$), all of its contributions to $\\operatorname{coeff}(t, k, j)$ are made solely by the next element $k_2$. To be more precise $\\operatorname{coeff}(t, k, j) = \\sum_{1 \\leq l \\leq t} \\operatorname{coeff}(l, k_2, j)$.&lt;/li&gt;\n&lt;li&gt;Clearly, this process is equivalent to starting off with an identity sequence, and at every iteration, replacing the current sequence with its prefix sum sequence, $\\vert S \\vert - 1$ times. The final sequence is going to be $\\operatorname{coeff}(t, i, j)$. Since only the size of $S$ is important, let&#39;s define $S(i, j) = \\vert S \\vert - 1$. Note that $S(i, j) \\leq \\lceil \\log_2{n} \\rceil$ (actually, $S(i, j) = \\operatorname{popcount}(i - j)$ but let&#39;s not get into that).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Using some combinatorics, we can derive the resultant sequence, and it&#39;s: $\\operatorname{coeff}(t, i, j) = \\frac{t(t + 1) \\dots (t + S(i, j) - 1)}{S(i, j)!}$. Since this value depends solely on $t$ and $S(i, j)$, let&#39;s define $\\operatorname{coeff2} (t, s) = \\frac{t(t + 1) \\dots (t + s - 1)}{s!}$.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;I understand that the iterative process that generates $S$ may feel a bit arbitrary/unmotivated, so here&#39;s a visual which shows the values of $k$ that we touch when generating $S$ for $i = 16, j = 3$:&lt;/p&gt;\n&lt;div style=\&quot;text-align:center\&quot;&gt;&lt;img src=\&quot;/assets/cf-1967c/img4.png\&quot;/&gt;&lt;/div&gt;\n&lt;p&gt;$\\operatorname{coeff}(t, i, j)$ depending solely on $t$ and $S(i, j)$, motivates: $$a(t)_i = \\sum_{i - \\operatorname{lowbit}(i) + 1 \\leq j \\leq i}{\\operatorname{coeff}(t, i, j) \\cdot a(0)_j} = \\sum_{c \\leq \\lceil \\log_2{n} \\rceil} (\\operatorname{coeff2}(t, c) \\cdot \\sum_{j : S(i, j) = c} a(0)_j)$$&lt;/p&gt;\n&lt;p&gt;All that remains is to find an efficient way to compute $\\sum_{j : S(i, j) = c} a(0)_j$ for all $c \\leq \\lceil \\log_2{n} \\rceil$ in the relevant range (we can just precompute the $O(\\log{n})$ required values of $\\operatorname{coeff2}(t, c)$).&lt;/p&gt;\n&lt;p&gt;Consider any $i$ and $j \\in [i - \\operatorname{lowbit}(i) + 1, i]$. There&#39;s a unique element $y \\in C(i)$ for which $j \\in [y - \\operatorname{lowbit}(y) + 1, y]$. It&#39;s easy to see that $S(i, j) = S(y, j) + 1$, so the contribution to $\\sum_{j : S(i, j) = c} a(0)_j$ from elements in $[y - \\operatorname{lowbit}(y) + 1, y]$ for $y \\in C(i)$ is going to be $\\sum_{j : S(y, j) = c - 1} a(0)_j$, and at long last, we have an efficient formulation for $\\sum_{j : S(i, j) = c} a(0)_j$:&lt;/p&gt;\n&lt;p&gt;$$\\sum_{j : S(i, j) = c} a(0)_j = \\sum_{y \\in C(i)} \\sum_{j : S(y, j) = c - 1} a(0)_j$$&lt;/p&gt;\n&lt;p&gt;(this is efficient because $\\vert C(i) \\vert \\leq \\lceil \\log_2{n} \\rceil$)&lt;/p&gt;\n&lt;p&gt;The final solution takes the following form:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;L = ceil(log2(n))\ncoeff2_t[L + 1] #compute this in whatever manner you&#39;d like\n\na_0[n + 1]      #initial values (to be recovered)\na_t[n + 1]      #final values (at time t)\ndp[n + 1][L + 1]    #dp[i][c] = sum(a_0[j]) for j : S(i, j) = c\n\nfor i from 1 to n:\n    compute C(i) in O(log(n))\n    for y in C(i)\n        for c from 1 to L\n            dp[i][c] += dp[y][c - 1]\n\n    a_0[i] = a_t[i]\n    for c from 1 to L\n        a_0[i] -= dp[i][c] * coeff2_t[c]\n\n    dp[i][0] = a_0[i]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This clearly runs in $O(n \\log^2{n})$ and that&#39;s fast enough to fit within the TL (although a $O(n \\log{n})$ solution exists).&lt;/p&gt;\n&lt;p&gt;I suck at explaining things in a concise manner, but it&#39;s probably just a result of sucking at thinking about things in a concise manner.&lt;/p&gt;\n&quot;],&quot;ssrFrontmatter&quot;:[0,{&quot;displayMode&quot;:[0,&quot;blog&quot;],&quot;title&quot;:[0,&quot;CF-1967C&quot;],&quot;date&quot;:[0,&quot;2025-09-04&quot;],&quot;tags&quot;:[1,[[0,&quot;editorial&quot;]]]}],&quot;ssrFlags&quot;:[0,{&quot;isBlog&quot;:[0,true],&quot;isMusings&quot;:[0,false]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;ContentPane&quot;,&quot;value&quot;:true}" await-children><!--[--><!--[!--><!--[1--><div class="h-full w-full bg-cover bg-center bg-no-repeat" style="background-image: url('/_astro/expoutput-1500w.BYFb0Fuh.webp');"></div><!--]--><!--]--><!--]--><!--astro:end--></astro-island> </main> <!-- Terminal --> <aside class="border-t border-zinc-700 md:border-t-0 md:border-l md:border-zinc-700 order-1 md:order-none"> <astro-island uid="1NBGTk" component-url="/_astro/TerminalPane.DRvAhnyr.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;TerminalPane&quot;,&quot;value&quot;:true}" await-children><!--[--><div class="h-full flex flex-col bg-zinc-900 desktop-wrapper svelte-twihms"><div class="md:hidden flex items-center justify-between px-3 py-2 border-b border-zinc-700"><span class="font-mono text-xs text-zinc-400">terminal</span> <button class="text-zinc-300" aria-label="Toggle terminal"><!--[!-->â–²<!--]--></button></div> <!--[1--><button class="desktop-toggle hidden md:flex svelte-twihms" aria-label="Collapse terminal">â–¶</button><!--]--> <div class="flex-1 overflow-hidden"><div class="terminal-content body svelte-twihms"><div class="terminal-shell h-full w-full svelte-1asehid focused"></div><!----></div></div></div><!--]--><!--astro:end--></astro-island> </aside> </div> </body></html>