<!DOCTYPE html><html lang="en" class="h-full"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Welcome to the Sunny Side!</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDGES615HV"></script><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-FDGES615HV");</script><script type="module">
    import { currentSkin } from '/src/stores/skin.ts';
    currentSkin.subscribe((skin) => {
      const rootCls = `h-full bg-bg text-text ${skin.classes.body}`;
      document.documentElement.className = rootCls;
      document.body.className = rootCls;
      // set CSS variables on :root
      const rs = document.documentElement.style;
      Object.entries(skin.cssVars).forEach(([k,v]) => rs.setProperty(`--${k}`, v));
      if (skin.inlineStyles?.body) {
        Object.assign(document.body.style, skin.inlineStyles.body);
      }
    });
  </script><link rel="stylesheet" href="/_astro/_slug_.B_lpCp7p.css"></head> <body class="h-full"> <div class="h-screen w-screen grid grid-cols-1 md:grid-cols-[1fr_auto] grid-rows-[auto_1fr] md:grid-rows-1"> <!-- Content --> <main class="overflow-y-auto overflow-x-hidden order-2 md:order-none bg-surface text-text transition-colors duration-150 ease-retro"> <div id="ssr-fallback" class="p-4 prose prose-invert max-w-none"><p>This is the harder version of the problem I previously discussed <a href="https://www.welcome-to-the-sunny-side.com/algo/problems/cf-2056f1.html">here</a>.</p>
<h3>Problem <a href="https://codeforces.com/problemset/problem/2056/F2">CF-2056F2</a></h3>
<h3>Statement</h3>
<blockquote>
<p>A sequence $a$ of $n$ integers is called <strong>good</strong> iff the following condition holds:</p>
<ul>
<li>Let $cnt_x$ be the number of occurrences of $x$ in the sequence $a$.</li>
<li>For all pairs $0 \leq i < j < m$, at least one of the following must be true:
<ul>
<li>$cnt_i = 0$</li>
<li>$cnt_j = 0$</li>
<li>$cnt_i \leq cnt_j$</li>
</ul>
</li>
</ul>
<p>In other words, if both $i$ and $j$ are present in the sequence, then the number of occurrences of $i$ must be <strong>less than or equal to</strong> the number of occurrences of $j$.</p>
<p>You are given integers $n$ and $m$. Compute the <strong>bitwise XOR of the medians</strong> of all <strong>good</strong> sequences $a$ of length $n$, where each element $a_i$ satisfies $0 \leq a_i < m$.</p>
</blockquote>
<p>Constraints:</p>
<ul>
<li>$n \leq 2^{10^5}$ (given to us in its binary form)</li>
<li>$m \leq 10^9$</li>
</ul>
<h3>Solution</h3>
<p>I'm going to pick up right where I left off in the previous blog.</p>
<p>Notice the changes in this version - the constraints on $k$ and $m$ have both increased by orders of magnitude, rendering our previous methods of approach (particularly those that required superlinear time w.r.t. $m$) useless.</p>
<p>Let's examine the algorithm we used earlier at a high level, and see if there are components vulnerable to optimization:</p>
<pre class="hljs"><code>ans = 0
for median q from 0 to m - 1:
    par = 0
    for (# of unique elements) x from 1 to min(q + 1, k):
        if (C(q, x - 1) * f(k, x)) % 2 == 1
            par ^= 1
    if par == 1
        ans ^= q
</code></pre>
<p>Firstly, we cannot compute required values of $f$ trivially in $O(k^2)$ like we did earlier, but we can analyse the recurrence and realize that $f(i,j) = 1 \iff (i - j) \text{AND} ((j - 1)/2) = 0$ (where $\text{AND}$ is the bitwise-AND operation). The proof for this is left as an exercise to the reader. We can therefore get rid of the $O(k^2)$ precomputation we were performing earlier, and look up values for $f(i, j)$ in $O(1)$.</p>
<p>Now, as we already know from the ideas introduced in the previous blog: $(\binom{q}{x - 1} \equiv 1 \pmod{2}) \iff ((x - 1) \text{ is a submask of } q)$, so when iterating over the number of unique elements $x$, we can simply ignore all $x$ where $x - 1$ isn't a submask of $q$. To make things more convenient, let's redefine $x$ to be the number of unique elements besides the median (just so we can say &quot;$x$ must be a submask of $q$&quot; instead of &quot;$x - 1$ must be a submask of $q$&quot;). The algorithm now becomes:</p>
<pre class="hljs"><code>ans = 0
for median q from 0 to m - 1:
    par = 0
    for submask x of q such that x &lt; k:
        par ^= f(k, x + 1)
    if par == 1
        ans ^= q
</code></pre>
<p>It should not be difficult to spot some glaring redundancy here, namely the fact that $\text{par}$ can be computed in an identical manner for several $q$!</p>
<p>Why is this the case? Notice that while $q$ can be rather large, we limit the submasks $x$ to the range $[0, k)$, where $k$ is at most $10^5$. This means that only the first $L = \lceil \log_2{k} \rceil$ bits of $q$ determine whether $x$ is a submask of $q$ or not.</p>
<p>To avoid this redundancy, we can instead compute the value of $\text{par}$ only once for every suffix mask (least significant bits) of $L$ bits (which is feasible since $2^L \approx O(k)$), and if it turns out to be $1$, we know that we would have individually XOR'd the answer with $q$ for all $q$ which have this mask as a suffix in our original algorithm, so we can now just try to process all of those individual changes together! Note that we can also conveniently ignore the restriction that $x < k$, and instead just let it be a submask of $2 ^ L$ as $f(k, x) = 0$ for $x > k$ in any case.</p>
<p>Our algorithm now reduces to the following:</p>
<pre class="hljs"><code>ans = 0
for (median suffix mask) p from 0 to (2^L - 1):
    par = 0
    for submask x of p:
        par ^= f(k, x + 1)
    if par == 1
        ans ^= (q : (the first L bits of q = p))
</code></pre>
<p>Now, the problem decomposes to two easy and independent subproblems:</p>
<ol>
<li>Finding $(\bigoplus_{x \subseteq p} f(k, x + 1)) \forall p \in [0, 2^L)$ (here $x \subseteq p$ means that $x$ is a submask of $p$). This is a standard application of SOS DP, and warrants no further explanation from me.</li>
<li>Finding  $(\bigoplus_{p \subseteq_L q} q) \forall p \in [0, 2^L)$. This can be done in $O(1)$ but I hate digit analysis far too much to not have mindlessly bashed it in $O(\log_2^3{m})$.</li>
</ol>
<p>So our final solution runs in $O(k \cdot (\log_2{k} + \log_2^3{m}))$ and can be optimized to $O(k \cdot \log_2{k})$ at the risk of one's sanity.</p>
<p>Code:</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">NULL</span>);
    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;
    cin &gt;&gt; t;
    <span class="hljs-keyword">while</span>(t --)
    {
        <span class="hljs-type">int</span> k, m;
        cin &gt;&gt; k &gt;&gt; m;

        string n;
        cin &gt;&gt; n;

        k = <span class="hljs-built_in">count</span>(n.<span class="hljs-built_in">begin</span>(), n.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);

        <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>((<span class="hljs-number">1</span> &lt;&lt; (L)) &lt;= k)
            ++ L;

        <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span>
        {
            <span class="hljs-keyword">if</span>(a &lt; b)
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> ((a - b) &amp; ((b - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;
        };

        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sos</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; L)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; (<span class="hljs-number">1</span> &lt;&lt; L); p ++)
            sos[p] = <span class="hljs-built_in">f</span>(k, p + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L; i ++)
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; (<span class="hljs-number">1</span> &lt;&lt; L); p ++)
                <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; i) &amp; p)
                    sos[p] ^= sos[p ^ (<span class="hljs-number">1</span> &lt;&lt; i)];

        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; (<span class="hljs-number">1</span> &lt;&lt; L); p ++)
        {
            <span class="hljs-keyword">if</span>(sos[p])
                <span class="hljs-keyword">if</span>(p &lt; m)
                {
                    <span class="hljs-type">int</span> xorsum = <span class="hljs-number">0</span>;
                    <span class="hljs-comment">// p0 p1 ... p(L-1) bit(L) bit(L+1) ... </span>
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = L; b &lt; <span class="hljs-number">30</span>; b ++)
                        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; b) + p &lt; m)
                        {
                            vector&lt;<span class="hljs-type">int</span>&gt; bits;
                            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = L; i &lt; <span class="hljs-number">30</span>; i ++)
                                <span class="hljs-keyword">if</span>(i != b)
                                    bits.<span class="hljs-built_in">push_back</span>(i);
                            
                            <span class="hljs-type">int</span> sz = bits.<span class="hljs-built_in">size</span>();
                            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = (<span class="hljs-number">1</span> &lt;&lt; sz) - <span class="hljs-number">1</span>, opt = <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">while</span>(l &lt;= r)
                            {
                                <span class="hljs-type">int</span> mid = (l + r)/<span class="hljs-number">2</span>;

                                <span class="hljs-type">int</span> sum = (<span class="hljs-number">1</span> &lt;&lt; b) + p;
                                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bits.<span class="hljs-built_in">size</span>(); i ++)
                                    <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; i) &amp; mid)
                                        sum += (<span class="hljs-number">1</span> &lt;&lt; bits[i]);
                                
                                <span class="hljs-keyword">if</span>(sum &lt; m)
                                    opt = mid, l = mid + <span class="hljs-number">1</span>;
                                <span class="hljs-keyword">else</span>
                                    r = mid - <span class="hljs-number">1</span>;
                            }

                            <span class="hljs-keyword">if</span>((opt + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>)
                                xorsum ^= (<span class="hljs-number">1</span> &lt;&lt; b);
                        }

                    {
                        vector&lt;<span class="hljs-type">int</span>&gt; bits;
                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = L; i &lt; <span class="hljs-number">30</span>; i ++)
                            bits.<span class="hljs-built_in">push_back</span>(i);
                        
                        <span class="hljs-type">int</span> sz = bits.<span class="hljs-built_in">size</span>();
                        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = (<span class="hljs-number">1</span> &lt;&lt; sz) - <span class="hljs-number">1</span>, opt = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">while</span>(l &lt;= r)
                        {
                            <span class="hljs-type">int</span> mid = (l + r)/<span class="hljs-number">2</span>;

                            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bits.<span class="hljs-built_in">size</span>(); i ++)
                                <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; i) &amp; mid)
                                    sum += (<span class="hljs-number">1</span> &lt;&lt; bits[i]);
                            
                            <span class="hljs-keyword">if</span>(sum + p &lt; m)
                                opt = mid, l = mid + <span class="hljs-number">1</span>;
                            <span class="hljs-keyword">else</span>
                                r = mid - <span class="hljs-number">1</span>;
                        }

                        <span class="hljs-keyword">if</span>((opt + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>)
                            xorsum ^= p;
                    }                    

                    ans ^= xorsum;
                }
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
}
</code></pre>
</div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="2259hm" component-url="/_astro/ContentPane.CWksgNm-.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{&quot;ssrPath&quot;:[0,&quot;/algo/problems/cf-2056f2.html&quot;],&quot;ssrHtml&quot;:[0,&quot;&lt;p&gt;This is the harder version of the problem I previously discussed &lt;a href=\&quot;https://www.welcome-to-the-sunny-side.com/algo/problems/cf-2056f1.html\&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;\n&lt;h3&gt;Problem &lt;a href=\&quot;https://codeforces.com/problemset/problem/2056/F2\&quot;&gt;CF-2056F2&lt;/a&gt;&lt;/h3&gt;\n&lt;h3&gt;Statement&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;A sequence $a$ of $n$ integers is called &lt;strong&gt;good&lt;/strong&gt; iff the following condition holds:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Let $cnt_x$ be the number of occurrences of $x$ in the sequence $a$.&lt;/li&gt;\n&lt;li&gt;For all pairs $0 \\leq i &lt; j &lt; m$, at least one of the following must be true:\n&lt;ul&gt;\n&lt;li&gt;$cnt_i = 0$&lt;/li&gt;\n&lt;li&gt;$cnt_j = 0$&lt;/li&gt;\n&lt;li&gt;$cnt_i \\leq cnt_j$&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;In other words, if both $i$ and $j$ are present in the sequence, then the number of occurrences of $i$ must be &lt;strong&gt;less than or equal to&lt;/strong&gt; the number of occurrences of $j$.&lt;/p&gt;\n&lt;p&gt;You are given integers $n$ and $m$. Compute the &lt;strong&gt;bitwise XOR of the medians&lt;/strong&gt; of all &lt;strong&gt;good&lt;/strong&gt; sequences $a$ of length $n$, where each element $a_i$ satisfies $0 \\leq a_i &lt; m$.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Constraints:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;$n \\leq 2^{10^5}$ (given to us in its binary form)&lt;/li&gt;\n&lt;li&gt;$m \\leq 10^9$&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Solution&lt;/h3&gt;\n&lt;p&gt;I&#39;m going to pick up right where I left off in the previous blog.&lt;/p&gt;\n&lt;p&gt;Notice the changes in this version - the constraints on $k$ and $m$ have both increased by orders of magnitude, rendering our previous methods of approach (particularly those that required superlinear time w.r.t. $m$) useless.&lt;/p&gt;\n&lt;p&gt;Let&#39;s examine the algorithm we used earlier at a high level, and see if there are components vulnerable to optimization:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;ans = 0\nfor median q from 0 to m - 1:\n    par = 0\n    for (# of unique elements) x from 1 to min(q + 1, k):\n        if (C(q, x - 1) * f(k, x)) % 2 == 1\n            par ^= 1\n    if par == 1\n        ans ^= q\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Firstly, we cannot compute required values of $f$ trivially in $O(k^2)$ like we did earlier, but we can analyse the recurrence and realize that $f(i,j) = 1 \\iff (i - j) \\text{AND} ((j - 1)/2) = 0$ (where $\\text{AND}$ is the bitwise-AND operation). The proof for this is left as an exercise to the reader. We can therefore get rid of the $O(k^2)$ precomputation we were performing earlier, and look up values for $f(i, j)$ in $O(1)$.&lt;/p&gt;\n&lt;p&gt;Now, as we already know from the ideas introduced in the previous blog: $(\\binom{q}{x - 1} \\equiv 1 \\pmod{2}) \\iff ((x - 1) \\text{ is a submask of } q)$, so when iterating over the number of unique elements $x$, we can simply ignore all $x$ where $x - 1$ isn&#39;t a submask of $q$. To make things more convenient, let&#39;s redefine $x$ to be the number of unique elements besides the median (just so we can say &amp;quot;$x$ must be a submask of $q$&amp;quot; instead of &amp;quot;$x - 1$ must be a submask of $q$&amp;quot;). The algorithm now becomes:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;ans = 0\nfor median q from 0 to m - 1:\n    par = 0\n    for submask x of q such that x &amp;lt; k:\n        par ^= f(k, x + 1)\n    if par == 1\n        ans ^= q\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It should not be difficult to spot some glaring redundancy here, namely the fact that $\\text{par}$ can be computed in an identical manner for several $q$!&lt;/p&gt;\n&lt;p&gt;Why is this the case? Notice that while $q$ can be rather large, we limit the submasks $x$ to the range $[0, k)$, where $k$ is at most $10^5$. This means that only the first $L = \\lceil \\log_2{k} \\rceil$ bits of $q$ determine whether $x$ is a submask of $q$ or not.&lt;/p&gt;\n&lt;p&gt;To avoid this redundancy, we can instead compute the value of $\\text{par}$ only once for every suffix mask (least significant bits) of $L$ bits (which is feasible since $2^L \\approx O(k)$), and if it turns out to be $1$, we know that we would have individually XOR&#39;d the answer with $q$ for all $q$ which have this mask as a suffix in our original algorithm, so we can now just try to process all of those individual changes together! Note that we can also conveniently ignore the restriction that $x &lt; k$, and instead just let it be a submask of $2 ^ L$ as $f(k, x) = 0$ for $x &gt; k$ in any case.&lt;/p&gt;\n&lt;p&gt;Our algorithm now reduces to the following:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;ans = 0\nfor (median suffix mask) p from 0 to (2^L - 1):\n    par = 0\n    for submask x of p:\n        par ^= f(k, x + 1)\n    if par == 1\n        ans ^= (q : (the first L bits of q = p))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, the problem decomposes to two easy and independent subproblems:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Finding $(\\bigoplus_{x \\subseteq p} f(k, x + 1)) \\forall p \\in [0, 2^L)$ (here $x \\subseteq p$ means that $x$ is a submask of $p$). This is a standard application of SOS DP, and warrants no further explanation from me.&lt;/li&gt;\n&lt;li&gt;Finding  $(\\bigoplus_{p \\subseteq_L q} q) \\forall p \\in [0, 2^L)$. This can be done in $O(1)$ but I hate digit analysis far too much to not have mindlessly bashed it in $O(\\log_2^3{m})$.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;So our final solution runs in $O(k \\cdot (\\log_2{k} + \\log_2^3{m}))$ and can be optimized to $O(k \\cdot \\log_2{k})$ at the risk of one&#39;s sanity.&lt;/p&gt;\n&lt;p&gt;Code:&lt;/p&gt;\n&lt;pre class=\&quot;hljs\&quot;&gt;&lt;code&gt;&lt;span class=\&quot;hljs-meta\&quot;&gt;#&lt;span class=\&quot;hljs-keyword\&quot;&gt;include&lt;/span&gt;&lt;span class=\&quot;hljs-string\&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;using&lt;/span&gt; &lt;span class=\&quot;hljs-keyword\&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-type\&quot;&gt;signed&lt;/span&gt; &lt;span class=\&quot;hljs-title\&quot;&gt;main&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    ios_base::&lt;span class=\&quot;hljs-built_in\&quot;&gt;sync_with_stdio&lt;/span&gt;(&lt;span class=\&quot;hljs-literal\&quot;&gt;false&lt;/span&gt;), cin.&lt;span class=\&quot;hljs-built_in\&quot;&gt;tie&lt;/span&gt;(&lt;span class=\&quot;hljs-literal\&quot;&gt;NULL&lt;/span&gt;);\n    &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; t = &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; t;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;while&lt;/span&gt;(t --)\n    {\n        &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; k, m;\n        cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; m;\n\n        string n;\n        cin &amp;gt;&amp;gt; n;\n\n        k = &lt;span class=\&quot;hljs-built_in\&quot;&gt;count&lt;/span&gt;(n.&lt;span class=\&quot;hljs-built_in\&quot;&gt;begin&lt;/span&gt;(), n.&lt;span class=\&quot;hljs-built_in\&quot;&gt;end&lt;/span&gt;(), &lt;span class=\&quot;hljs-string\&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;);\n\n        &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; L = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=\&quot;hljs-keyword\&quot;&gt;while&lt;/span&gt;((&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (L)) &amp;lt;= k)\n            ++ L;\n\n        &lt;span class=\&quot;hljs-keyword\&quot;&gt;auto&lt;/span&gt; f = [&amp;amp;](&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; a, &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; b) -&amp;gt; &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt;\n        {\n            &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(a &amp;lt; b)\n                &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n            &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; ((a - b) &amp;amp; ((b - &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;)) == &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n        };\n\n        &lt;span class=\&quot;hljs-function\&quot;&gt;vector&amp;lt;&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=\&quot;hljs-title\&quot;&gt;sos&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; L)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; p = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; p &amp;lt; (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; L); p ++)\n            sos[p] = &lt;span class=\&quot;hljs-built_in\&quot;&gt;f&lt;/span&gt;(k, p + &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;);\n        &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; i = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; i &amp;lt; L; i ++)\n            &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; p = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; p &amp;lt; (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; L); p ++)\n                &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i) &amp;amp; p)\n                    sos[p] ^= sos[p ^ (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)];\n\n        &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; ans = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n        &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; p = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; p &amp;lt; (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; L); p ++)\n        {\n            &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(sos[p])\n                &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(p &amp;lt; m)\n                {\n                    &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; xorsum = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n                    &lt;span class=\&quot;hljs-comment\&quot;&gt;// p0 p1 ... p(L-1) bit(L) bit(L+1) ... &lt;/span&gt;\n                    &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; b = L; b &amp;lt; &lt;span class=\&quot;hljs-number\&quot;&gt;30&lt;/span&gt;; b ++)\n                        &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; b) + p &amp;lt; m)\n                        {\n                            vector&amp;lt;&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt;&amp;gt; bits;\n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; i = L; i &amp;lt; &lt;span class=\&quot;hljs-number\&quot;&gt;30&lt;/span&gt;; i ++)\n                                &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(i != b)\n                                    bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;push_back&lt;/span&gt;(i);\n                            \n                            &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; sz = bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;size&lt;/span&gt;();\n                            &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; l = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;, r = (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; sz) - &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;, opt = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;while&lt;/span&gt;(l &amp;lt;= r)\n                            {\n                                &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; mid = (l + r)/&lt;span class=\&quot;hljs-number\&quot;&gt;2&lt;/span&gt;;\n\n                                &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; sum = (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; b) + p;\n                                &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; i = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; i &amp;lt; bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;size&lt;/span&gt;(); i ++)\n                                    &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i) &amp;amp; mid)\n                                        sum += (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; bits[i]);\n                                \n                                &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(sum &amp;lt; m)\n                                    opt = mid, l = mid + &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;;\n                                &lt;span class=\&quot;hljs-keyword\&quot;&gt;else&lt;/span&gt;\n                                    r = mid - &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;;\n                            }\n\n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((opt + &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;) &amp;amp; &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;)\n                                xorsum ^= (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; b);\n                        }\n\n                    {\n                        vector&amp;lt;&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt;&amp;gt; bits;\n                        &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; i = L; i &amp;lt; &lt;span class=\&quot;hljs-number\&quot;&gt;30&lt;/span&gt;; i ++)\n                            bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;push_back&lt;/span&gt;(i);\n                        \n                        &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; sz = bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;size&lt;/span&gt;();\n                        &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; l = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;, r = (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; sz) - &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;, opt = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n                        &lt;span class=\&quot;hljs-keyword\&quot;&gt;while&lt;/span&gt;(l &amp;lt;= r)\n                        {\n                            &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; mid = (l + r)/&lt;span class=\&quot;hljs-number\&quot;&gt;2&lt;/span&gt;;\n\n                            &lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; sum = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;;\n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;for&lt;/span&gt;(&lt;span class=\&quot;hljs-type\&quot;&gt;int&lt;/span&gt; i = &lt;span class=\&quot;hljs-number\&quot;&gt;0&lt;/span&gt;; i &amp;lt; bits.&lt;span class=\&quot;hljs-built_in\&quot;&gt;size&lt;/span&gt;(); i ++)\n                                &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i) &amp;amp; mid)\n                                    sum += (&lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; bits[i]);\n                            \n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;(sum + p &amp;lt; m)\n                                opt = mid, l = mid + &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;;\n                            &lt;span class=\&quot;hljs-keyword\&quot;&gt;else&lt;/span&gt;\n                                r = mid - &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;;\n                        }\n\n                        &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;((opt + &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;) &amp;amp; &lt;span class=\&quot;hljs-number\&quot;&gt;1&lt;/span&gt;)\n                            xorsum ^= p;\n                    }                    \n\n                    ans ^= xorsum;\n                }\n        }\n        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&quot;],&quot;ssrFrontmatter&quot;:[0,{&quot;displayMode&quot;:[0,&quot;blog&quot;],&quot;title&quot;:[0,&quot;CF-2056F2&quot;],&quot;date&quot;:[0,&quot;2025-09-02&quot;],&quot;tags&quot;:[1,[[0,&quot;editorial&quot;]]]}],&quot;ssrFlags&quot;:[0,{&quot;isBlog&quot;:[0,true],&quot;isMusings&quot;:[0,false]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;ContentPane&quot;,&quot;value&quot;:true}" await-children><!--[--><!--[!--><!--[1--><div class="h-full w-full bg-cover bg-center bg-no-repeat" style="background-image: url('/_astro/expoutput-1500w.BYFb0Fuh.webp');"></div><!--]--><!--]--><!--]--><!--astro:end--></astro-island> </main> <!-- Terminal --> <aside class="border-t border-zinc-700 md:border-t-0 md:border-l md:border-zinc-700 order-1 md:order-none"> <astro-island uid="1NBGTk" component-url="/_astro/TerminalPane.DRvAhnyr.js" component-export="default" renderer-url="/_astro/client.svelte.B5-DceF6.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;TerminalPane&quot;,&quot;value&quot;:true}" await-children><!--[--><div class="h-full flex flex-col bg-zinc-900 desktop-wrapper svelte-twihms"><div class="md:hidden flex items-center justify-between px-3 py-2 border-b border-zinc-700"><span class="font-mono text-xs text-zinc-400">terminal</span> <button class="text-zinc-300" aria-label="Toggle terminal"><!--[!-->▲<!--]--></button></div> <!--[1--><button class="desktop-toggle hidden md:flex svelte-twihms" aria-label="Collapse terminal">▶</button><!--]--> <div class="flex-1 overflow-hidden"><div class="terminal-content body svelte-twihms"><div class="terminal-shell h-full w-full svelte-1asehid focused"></div><!----></div></div></div><!--]--><!--astro:end--></astro-island> </aside> </div> </body></html>